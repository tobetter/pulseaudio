commit 6aa84d6db0180ce4d12a17818fb6527a12f2e8fb
Author: Pino Toscano <toscano.pino@tiscali.it>
Date:   Mon Nov 14 11:33:47 2011 +0100

    pipe: use pa_pipe_buf instead of the macro PIPE_BUF
    
    This helps when porting to platforms that lack PIPE_BUF.
    
    See bug #42715

diff --git a/src/modules/module-pipe-source.c b/src/modules/module-pipe-source.c
index a941f08..3335907 100644
--- a/src/modules/module-pipe-source.c
+++ b/src/modules/module-pipe-source.c
@@ -286,7 +286,7 @@ int pa__init(pa_module*m) {
 
     pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
     pa_source_set_rtpoll(u->source, u->rtpoll);
-    pa_source_set_fixed_latency(u->source, pa_bytes_to_usec(PIPE_BUF, &u->source->sample_spec));
+    pa_source_set_fixed_latency(u->source, pa_bytes_to_usec(pa_pipe_buf(u->fd), &u->source->sample_spec));
 
     u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 1);
     pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);

commit 992333697f29cf83208f92d2a64e984b778547f0
Author: Pino Toscano <toscano.pino@tiscali.it>
Date:   Mon Nov 14 11:44:43 2011 +0100

    rtp: use the right type when checking cmsg_type
    
    Use SCM_* instead of SO_* when checking the type of each cmsghdr.
    
    See bug #42715

diff --git a/src/modules/rtp/rtp.c b/src/modules/rtp/rtp.c
index 05c736a..178717c 100644
--- a/src/modules/rtp/rtp.c
+++ b/src/modules/rtp/rtp.c
@@ -278,14 +278,14 @@ int pa_rtp_recv(pa_rtp_context *c, pa_memchunk *chunk, pa_mempool *pool, struct
     }
 
     for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
-        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SO_TIMESTAMP) {
+        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_TIMESTAMP) {
             memcpy(tstamp, CMSG_DATA(cm), sizeof(struct timeval));
             found_tstamp = TRUE;
             break;
         }
 
     if (!found_tstamp) {
-        pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!");
+        pa_log_warn("Couldn't find SCM_TIMESTAMP data in auxiliary recvmsg() data!");
         memset(tstamp, 0, sizeof(tstamp));
     }

 
commit e2876aeb408429b1363080ad77f45690d22e5794
Author: Pino Toscano <toscano.pino@tiscali.it>
Date:   Mon Nov 14 11:48:47 2011 +0100

    module-rtp-recv: fail when SO_TIMESTAMP is not defined
    
    SO_TIMESTAMP is not POSIX and not available in any platform, so just fail
    if the current platform does not have it.
    
    See bug #42715

diff --git a/src/modules/rtp/module-rtp-recv.c b/src/modules/rtp/module-rtp-recv.c
index 9d86805..412f4c3 100644
--- a/src/modules/rtp/module-rtp-recv.c
+++ b/src/modules/rtp/module-rtp-recv.c
@@ -428,11 +428,16 @@ static int mcast_socket(const struct sockaddr* sa, socklen_t salen) {
 
     pa_make_udp_socket_low_delay(fd);
 
+#ifdef SO_TIMESTAMP
     one = 1;
     if (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMP, &one, sizeof(one)) < 0) {
         pa_log("SO_TIMESTAMP failed: %s", pa_cstrerror(errno));
         goto fail;
     }
+#else
+    pa_log("SO_TIMESTAMP unsupported on this platform");
+    goto fail;
+#endif
 
     one = 1;
     if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0) {

commit 9a92327c27a5a321fd15274fb5b1b180e5417a74
Author: Pino Toscano <toscano.pino@tiscali.it>
Date:   Mon Nov 14 11:58:25 2011 +0100

    mutex: handle gracefully if a PTHREAD_PRIO_INHERIT protocol cannot be set
    
    This adds an additional check for unavailable PTHREAD_PRIO_INHERIT to the
    fallback work done in ca717643ee768307475fc36ea29d920a13db0a8e
    
    See bug #42715

diff --git a/src/pulsecore/mutex-posix.c b/src/pulsecore/mutex-posix.c
index 634087d..d90525b 100644
--- a/src/pulsecore/mutex-posix.c
+++ b/src/pulsecore/mutex-posix.c
@@ -50,8 +50,10 @@ pa_mutex* pa_mutex_new(pa_bool_t recursive, pa_bool_t inherit_priority) {
         pa_assert_se(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) == 0);
 
 #ifdef HAVE_PTHREAD_PRIO_INHERIT
-    if (inherit_priority)
-        pa_assert_se(pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT) == 0);
+    if (inherit_priority) {
+        r = pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
+        pa_assert(r == 0 || r == ENOTSUP);
+    }
 #endif
 
     m = pa_xnew(pa_mutex, 1);
commit b6a3cc3ad6b2efff27f79927e42129ad9037130a
Author: Pino Toscano <toscano.pino@tiscali.it>
Date:   Mon Nov 14 12:07:12 2011 +0100

    pacmd: dynamically allocate ibuf and obuf
    
    Use pa_pipe_buf to determine the minimum size for ibuf and obuf, taking into
    account the two descriptors that use each of them.
    
    See bug #42715

diff --git a/src/utils/pacmd.c b/src/utils/pacmd.c
index 6d4cc9b..802832c 100644
--- a/src/utils/pacmd.c
+++ b/src/utils/pacmd.c
@@ -47,8 +47,9 @@ int main(int argc, char*argv[]) {
     int fd = -1;
     int ret = 1, i;
     struct sockaddr_un sa;
-    char ibuf[PIPE_BUF], obuf[PIPE_BUF];
-    size_t ibuf_index, ibuf_length, obuf_index, obuf_length;
+    char *ibuf = NULL;
+    char *obuf = NULL;
+    size_t ibuf_size, ibuf_index, ibuf_length, obuf_size, obuf_index, obuf_length;
     char *cli;
     pa_bool_t ibuf_eof, obuf_eof, ibuf_closed, obuf_closed;
     struct pollfd pollfd[3];
@@ -104,6 +105,11 @@ int main(int argc, char*argv[]) {
         goto fail;
     }
 
+    i = pa_pipe_buf(fd);
+    ibuf_size = PA_MIN(i, pa_pipe_buf(STDIN_FILENO));
+    ibuf = pa_xmalloc(ibuf_size);
+    obuf_size = PA_MIN(i, pa_pipe_buf(STDOUT_FILENO));
+    obuf = pa_xmalloc(obuf_size);
     ibuf_index = ibuf_length = obuf_index = obuf_length = 0;
     ibuf_eof = obuf_eof = ibuf_closed = obuf_closed = FALSE;
 
@@ -111,11 +117,11 @@ int main(int argc, char*argv[]) {
         for (i = 1; i < argc; i++) {
             size_t k;
 
-            k = PA_MIN(sizeof(ibuf) - ibuf_length, strlen(argv[i]));
+            k = PA_MIN(ibuf_size - ibuf_length, strlen(argv[i]));
             memcpy(ibuf + ibuf_length, argv[i], k);
             ibuf_length += k;
 
-            if (ibuf_length < sizeof(ibuf)) {
+            if (ibuf_length < ibuf_size) {
                 ibuf[ibuf_length] = i < argc-1 ? ' ' : '\n';
                 ibuf_length++;
             }
@@ -184,7 +190,7 @@ int main(int argc, char*argv[]) {
                 ssize_t r;
                 pa_assert(ibuf_length <= 0);
 
-                if ((r = pa_read(STDIN_FILENO, ibuf, sizeof(ibuf), &stdin_type)) <= 0) {
+                if ((r = pa_read(STDIN_FILENO, ibuf, ibuf_size, &stdin_type)) <= 0) {
                     if (r < 0) {
                         pa_log(_("read(): %s"), strerror(errno));
                         goto fail;
@@ -204,7 +210,7 @@ int main(int argc, char*argv[]) {
                 ssize_t r;
                 pa_assert(obuf_length <= 0);
 
-                if ((r = pa_read(fd, obuf, sizeof(obuf), &fd_type)) <= 0) {
+                if ((r = pa_read(fd, obuf, obuf_size, &fd_type)) <= 0) {
                     if (r < 0) {
                         pa_log(_("read(): %s"), strerror(errno));
                         goto fail;
@@ -262,5 +268,8 @@ fail:
     if (fd >= 0)
         pa_close(fd);
 
+    pa_xfree(obuf);
+    pa_xfree(ibuf);
+
     return ret;
 }


commit 8499afc36f71342ec6118dc81adb85bc1b3f4aea
Author: Pino Toscano <pino@debian.org>
Date:   Mon Mar 19 12:42:15 2012 +0000

    libpulse: Cope with systems not implementing SA_NOCLDWAIT
    
    Even though SA_NOCLDWAIT is a POSIX mandatory flag the Hurd doesn't
    implement it. So let's only check for it if it's defined.

diff --git a/src/pulse/context.c b/src/pulse/context.c
index e03d88c..5bd3448 100644
--- a/src/pulse/context.c
+++ b/src/pulse/context.c
@@ -660,7 +660,11 @@ static int context_autospawn(pa_context *c) {
         goto fail;
     }
 
+#ifdef SA_NOCLDWAIT
     if ((sa.sa_flags & SA_NOCLDWAIT) || sa.sa_handler == SIG_IGN) {
+#else
+    if (sa.sa_handler == SIG_IGN) {
+#endif
         pa_log_debug("Process disabled waitpid(), cannot autospawn.");
         pa_context_fail(c, PA_ERR_CONNECTIONREFUSED);
         goto fail;

