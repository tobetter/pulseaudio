Index: pulseaudio-0.9.19/src/modules/alsa/alsa-sink.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/alsa/alsa-sink.c	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/alsa/alsa-sink.c	2009-10-06 18:36:10.000000000 -0400
@@ -927,7 +927,7 @@
 
     pa_log_debug("setting avail_min=%lu", (unsigned long) avail_min);
 
-    if ((err = pa_alsa_set_sw_params(u->pcm_handle, avail_min)) < 0) {
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, avail_min, !u->use_tsched)) < 0) {
         pa_log("Failed to set software parameters: %s", pa_alsa_strerror(err));
         return err;
     }
Index: pulseaudio-0.9.19/src/modules/alsa/alsa-source.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/alsa/alsa-source.c	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/alsa/alsa-source.c	2009-10-06 18:36:10.000000000 -0400
@@ -877,7 +877,7 @@
 
     pa_log_debug("setting avail_min=%lu", (unsigned long) avail_min);
 
-    if ((err = pa_alsa_set_sw_params(u->pcm_handle, avail_min)) < 0) {
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, avail_min, !u->use_tsched)) < 0) {
         pa_log("Failed to set software parameters: %s", pa_alsa_strerror(err));
         return err;
     }
Index: pulseaudio-0.9.19/src/modules/alsa/alsa-util.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/alsa/alsa-util.c	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/alsa/alsa-util.c	2009-10-06 18:36:10.000000000 -0400
@@ -403,7 +403,7 @@
     return ret;
 }
 
-int pa_alsa_set_sw_params(snd_pcm_t *pcm, snd_pcm_uframes_t avail_min) {
+int pa_alsa_set_sw_params(snd_pcm_t *pcm, snd_pcm_uframes_t avail_min, pa_bool_t period_event) {
     snd_pcm_sw_params_t *swparams;
     snd_pcm_uframes_t boundary;
     int err;
@@ -417,7 +417,7 @@
         return err;
     }
 
-    if ((err = snd_pcm_sw_params_set_period_event(pcm, swparams, 0)) < 0) {
+    if ((err = snd_pcm_sw_params_set_period_event(pcm, swparams, period_event)) < 0) {
         pa_log_warn("Unable to disable period event: %s\n", pa_alsa_strerror(err));
         return err;
     }
Index: pulseaudio-0.9.19/src/modules/alsa/alsa-util.h
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/alsa/alsa-util.h	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/alsa/alsa-util.h	2009-10-06 18:36:10.000000000 -0400
@@ -51,7 +51,8 @@
 
 int pa_alsa_set_sw_params(
         snd_pcm_t *pcm,
-        snd_pcm_uframes_t avail_min);
+        snd_pcm_uframes_t avail_min,
+        pa_bool_t period_event);
 
 /* Picks a working mapping from the profile set based on the specified ss/map */
 snd_pcm_t *pa_alsa_open_by_device_id_auto(
Index: pulseaudio-0.9.19/src/modules/bluetooth/module-bluetooth-device.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/bluetooth/module-bluetooth-device.c	2009-10-06 18:36:10.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/bluetooth/module-bluetooth-device.c	2009-10-06 18:36:10.000000000 -0400
@@ -74,7 +74,8 @@
         "profile=<a2dp|hsp> "
         "rate=<sample rate> "
         "channels=<number of channels> "
-        "path=<device object path>");
+        "path=<device object path> "
+        "auto_connect=<automatically connect?>");
 
 /*
 #ifdef NOKIA
@@ -98,6 +99,7 @@
     "rate",
     "channels",
     "path",
+    "auto_connect",
 #ifdef NOKIA
     "sco_sink",
     "sco_source",
@@ -141,6 +143,7 @@
     char *address;
     char *path;
     pa_bluetooth_discovery *discovery;
+    pa_bool_t auto_connect;
 
     pa_dbus_connection *connection;
 
@@ -399,7 +402,7 @@
         pa_assert(u->profile == PROFILE_HSP);
         msg.getcaps_req.transport = BT_CAPABILITIES_TRANSPORT_SCO;
     }
-    msg.getcaps_req.flags = BT_FLAG_AUTOCONNECT;
+    msg.getcaps_req.flags = u->auto_connect ? BT_FLAG_AUTOCONNECT : 0;
 
     if (service_send(u, &msg.getcaps_req.h) < 0)
         return -1;
@@ -2367,6 +2370,12 @@
         goto fail;
     }
 
+    u->auto_connect = TRUE;
+    if (pa_modargs_get_value_boolean(ma, "auto_connect", &u->auto_connect)) {
+        pa_log("Failed to parse auto_connect= argument");
+        goto fail;
+    }
+
     channels = u->sample_spec.channels;
     if (pa_modargs_get_value_u32(ma, "channels", &channels) < 0 ||
         channels <= 0 || channels > PA_CHANNELS_MAX) {
Index: pulseaudio-0.9.19/src/modules/bluetooth/module-bluetooth-discover.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/bluetooth/module-bluetooth-discover.c	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/bluetooth/module-bluetooth-discover.c	2009-10-06 18:36:10.000000000 -0400
@@ -117,7 +117,7 @@
 #endif
 
             if (d->audio_source_state >= PA_BT_AUDIO_STATE_CONNECTED)
-                args = pa_sprintf_malloc("%s profile=\"a2dp_source\"", args);
+                args = pa_sprintf_malloc("%s profile=\"a2dp_source\" auto_connect=no", args);
 
             pa_log_debug("Loading module-bluetooth-device %s", args);
             m = pa_module_load(u->module->core, "module-bluetooth-device", args);
Index: pulseaudio-0.9.19/src/modules/module-loopback.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/module-loopback.c	2009-10-06 18:09:54.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/module-loopback.c	2009-10-06 18:36:10.000000000 -0400
@@ -102,7 +102,7 @@
 static const char* const valid_modargs[] = {
     "source",
     "sink",
-    "latency",
+    "latency_msec",
     "format",
     "rate",
     "channels",
Index: pulseaudio-0.9.19/src/modules/module-position-event-sounds.c
===================================================================
--- pulseaudio-0.9.19.orig/src/modules/module-position-event-sounds.c	2009-10-06 18:38:07.000000000 -0400
+++ pulseaudio-0.9.19/src/modules/module-position-event-sounds.c	2009-10-06 18:38:17.000000000 -0400
@@ -74,7 +74,7 @@
 }
 
 static pa_hook_result_t sink_input_fixate_hook_callback(pa_core *core, pa_sink_input_new_data *data, struct userdata *u) {
-    const char *hpos, *vpos, *role;
+    const char *hpos, *vpos, *role, *id;
     double f;
     char t[PA_CVOLUME_SNPRINT_MAX];
     pa_cvolume v;
@@ -87,6 +87,22 @@
     if (!pa_streq(role, "event"))
         return PA_HOOK_OK;
 
+    if ((id = pa_proplist_gets(data->proplist, PA_PROP_EVENT_ID))) {
+
+        /* The test sounds should never be positioned in space, since
+         * they might be trigered themselves to configure the speakers
+         * in space, which we don't want to mess up. */
+
+        if (pa_startswith(id, "audio-channel-"))
+            return PA_HOOK_OK;
+
+        if (pa_streq(id, "audio-volume-change"))
+            return PA_HOOK_OK;
+
+        if (pa_streq(id, "audio-test-signal"))
+            return PA_HOOK_OK;
+    }
+
     if (!(hpos = pa_proplist_gets(data->proplist, PA_PROP_EVENT_MOUSE_HPOS)))
         hpos = pa_proplist_gets(data->proplist, PA_PROP_WINDOW_HPOS);
 
