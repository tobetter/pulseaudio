Index: pulseaudio-0.9.14/src/modules/module-alsa-sink.c
===================================================================
--- pulseaudio-0.9.14.orig/src/modules/module-alsa-sink.c	2009-04-07 20:17:53.000000000 -0400
+++ pulseaudio-0.9.14/src/modules/module-alsa-sink.c	2009-04-07 20:21:25.000000000 -0400
@@ -94,8 +94,8 @@
 #define DEFAULT_DEVICE "default"
 #define DEFAULT_TSCHED_BUFFER_USEC (2*PA_USEC_PER_SEC)            /* 2s */
 #define DEFAULT_TSCHED_WATERMARK_USEC (20*PA_USEC_PER_MSEC)       /* 20ms */
-#define TSCHED_MIN_SLEEP_USEC (3*PA_USEC_PER_MSEC)                /* 3ms */
-#define TSCHED_MIN_WAKEUP_USEC (3*PA_USEC_PER_MSEC)               /* 3ms */
+#define TSCHED_MIN_SLEEP_USEC (10*PA_USEC_PER_MSEC)               /* 10ms */
+#define TSCHED_MIN_WAKEUP_USEC (4*PA_USEC_PER_MSEC)               /* 4ms */
 
 struct userdata {
     pa_core *core;
@@ -117,7 +117,7 @@
     pa_bool_t mixer_seperate_channels;
     pa_cvolume hardware_volume;
 
-    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark;
+    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark, hwbuf_unused, min_sleep, min_wakeup;
     unsigned nfragments;
     pa_memchunk memchunk;
 
@@ -132,37 +132,66 @@
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
 
     pa_smoother *smoother;
-    int64_t frame_index;
+    uint64_t write_count;
     uint64_t since_start;
-
-    snd_pcm_sframes_t hwbuf_unused_frames;
 };
 
+static void fix_min_sleep_wakeup(struct userdata *u) {
+    size_t max_use, max_use_2;
+
+    pa_assert(u);
+
+    max_use = u->hwbuf_size - u->hwbuf_unused;
+    max_use_2 = pa_frame_align(max_use/2, &u->sink->sample_spec);
+
+    u->min_sleep = pa_usec_to_bytes(TSCHED_MIN_SLEEP_USEC, &u->sink->sample_spec);
+    u->min_sleep = PA_CLAMP(u->min_sleep, u->frame_size, max_use_2);
+
+    u->min_wakeup = pa_usec_to_bytes(TSCHED_MIN_WAKEUP_USEC, &u->sink->sample_spec);
+    u->min_wakeup = PA_CLAMP(u->min_wakeup, u->frame_size, max_use_2);
+}
+
 static void fix_tsched_watermark(struct userdata *u) {
     size_t max_use;
-    size_t min_sleep, min_wakeup;
     pa_assert(u);
 
-    max_use = u->hwbuf_size - (size_t) u->hwbuf_unused_frames * u->frame_size;
+    max_use = u->hwbuf_size - u->hwbuf_unused;
+
+    if (u->tsched_watermark > max_use - u->min_sleep)
+        u->tsched_watermark = max_use - u->min_sleep;
+
+    if (u->tsched_watermark < u->min_wakeup)
+        u->tsched_watermark = u->min_wakeup;
+}
 
-    min_sleep = pa_usec_to_bytes(TSCHED_MIN_SLEEP_USEC, &u->sink->sample_spec);
-    min_wakeup = pa_usec_to_bytes(TSCHED_MIN_WAKEUP_USEC, &u->sink->sample_spec);
+static void adjust_after_underrun(struct userdata *u) {
+    size_t old_watermark;
+    pa_usec_t old_min_latency, new_min_latency;
 
-    if (min_sleep > max_use/2)
-        min_sleep = pa_frame_align(max_use/2, &u->sink->sample_spec);
-    if (min_sleep < u->frame_size)
-        min_sleep = u->frame_size;
+    pa_assert(u);
 
-    if (min_wakeup > max_use/2)
-        min_wakeup = pa_frame_align(max_use/2, &u->sink->sample_spec);
-    if (min_wakeup < u->frame_size)
-        min_wakeup = u->frame_size;
+    /* First, just try to increase the watermark */
+    old_watermark = u->tsched_watermark;
+    u->tsched_watermark *= 2;
+    fix_tsched_watermark(u);
+
+    if (old_watermark != u->tsched_watermark) {
+        pa_log_notice("Increasing wakeup watermark to %0.2f ms",
+                      (double) pa_bytes_to_usec(u->tsched_watermark, &u->sink->sample_spec) / PA_USEC_PER_MSEC);
+        return;
+    }
 
-    if (u->tsched_watermark > max_use-min_sleep)
-        u->tsched_watermark = max_use-min_sleep;
+    /* Hmm, we cannot increase the watermark any further, hence let's raise the latency */
+    old_min_latency = u->sink->thread_info.min_latency;
+    new_min_latency = PA_MIN(old_min_latency * 2, u->sink->thread_info.max_latency);
+
+    if (old_min_latency != new_min_latency) {
+        pa_log_notice("Increasing minimal latency to %0.2f ms",
+                      (double) new_min_latency / PA_USEC_PER_MSEC);
 
-    if (u->tsched_watermark < min_wakeup)
-        u->tsched_watermark = min_wakeup;
+        pa_sink_update_latency_range(u->sink, new_min_latency, u->sink->thread_info.max_latency);
+        return;
+    }
 }
 
 static void hw_sleep_time(struct userdata *u, pa_usec_t *sleep_usec, pa_usec_t*process_usec) {
@@ -178,17 +207,13 @@
     if (usec == (pa_usec_t) -1)
         usec = pa_bytes_to_usec(u->hwbuf_size, &u->sink->sample_spec);
 
-/*     pa_log_debug("hw buffer time: %u ms", (unsigned) (usec / PA_USEC_PER_MSEC)); */
-
     wm = pa_bytes_to_usec(u->tsched_watermark, &u->sink->sample_spec);
 
-    if (usec >= wm) {
-        *sleep_usec = usec - wm;
-        *process_usec = wm;
-    } else
-        *process_usec = *sleep_usec = usec / 2;
+    if (wm > usec)
+        wm = usec/2;
 
-/*     pa_log_debug("after watermark: %u ms", (unsigned) (*sleep_usec / PA_USEC_PER_MSEC)); */
+    *sleep_usec = usec - wm;
+    *process_usec = wm;
 }
 
 static int try_recover(struct userdata *u, const char *call, int err) {
@@ -203,38 +228,33 @@
     if (err == -EPIPE)
         pa_log_debug("%s: Buffer underrun!", call);
 
-    if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0) {
-        u->first = TRUE;
-        u->since_start = 0;
-        return 0;
+    if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) < 0) {
+        pa_log("%s: %s", call, snd_strerror(err));
+        return -1;
     }
 
-    pa_log("%s: %s", call, snd_strerror(err));
-    return -1;
+    u->first = TRUE;
+    u->since_start = 0;
+    return 0;
 }
 
-static size_t check_left_to_play(struct userdata *u, snd_pcm_sframes_t n) {
+static size_t check_left_to_play(struct userdata *u, size_t n_bytes) {
     size_t left_to_play;
 
-    if ((size_t) n*u->frame_size < u->hwbuf_size)
-        left_to_play = u->hwbuf_size - ((size_t) n*u->frame_size);
-    else
+    /* We use <= instead of < for this check here because an underrun
+     * only happens after the last sample was processed, not already when
+     * it is removed from the buffer. This is particularly important
+     * when block transfer is used. */
+
+    if (n_bytes <= u->hwbuf_size)
+        left_to_play = u->hwbuf_size - n_bytes;
+    else {
         left_to_play = 0;
+        if (!u->first && !u->after_rewind) {
+            pa_log_info("Underrun!");
 
-    if (left_to_play > 0) {
-/*         pa_log_debug("%0.2f ms left to play", (double) pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) / PA_USEC_PER_MSEC); */
-    } else if (!u->first && !u->after_rewind) {
-        pa_log_info("Underrun!");
-
-        if (u->use_tsched) {
-            size_t old_watermark = u->tsched_watermark;
-
-            u->tsched_watermark *= 2;
-            fix_tsched_watermark(u);
-
-            if (old_watermark != u->tsched_watermark)
-                pa_log_notice("Increasing wakeup watermark to %0.2f ms",
-                              (double) pa_bytes_to_usec(u->tsched_watermark, &u->sink->sample_spec) / PA_USEC_PER_MSEC);
+            if (u->use_tsched)
+                adjust_after_underrun(u);
         }
     }
 
@@ -242,9 +262,10 @@
 }
 
 static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
-    int work_done = 0;
+    pa_bool_t work_done = TRUE;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_play;
+    unsigned j = 0;
 
     pa_assert(u);
     pa_sink_assert_ref(u->sink);
@@ -254,10 +275,9 @@
 
     for (;;) {
         snd_pcm_sframes_t n;
+        size_t n_bytes;
         int r;
 
-        snd_pcm_hwsync(u->pcm_handle);
-
         /* First we determine how many samples are missing to fill the
          * buffer up to 100% */
 
@@ -269,7 +289,8 @@
             return r;
         }
 
-        left_to_play = check_left_to_play(u, n);
+        n_bytes = (size_t) n * u->frame_size;
+        left_to_play = check_left_to_play(u, n_bytes);
 
         if (u->use_tsched)
 
@@ -283,18 +304,20 @@
                 pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+        if (PA_UNLIKELY(n_bytes <= u->hwbuf_unused)) {
 
             if (u->use_tsched && polled)
-                pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
+                pa_log_debug("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
                        "Most likely this is a Linux bug. Please report this issue to the ALSA developers. "
                        "We were woken up with POLLOUT set -- however a subsequent snd_pcm_avail_update() returned 0.");
 
             break;
         }
 
-        n -= u->hwbuf_unused_frames;
+        if (++j > 10)
+            break;
 
+        n_bytes -= u->hwbuf_unused;
         polled = FALSE;
 
 /*         pa_log_debug("Filling up"); */
@@ -304,9 +327,10 @@
             void *p;
             int err;
             const snd_pcm_channel_area_t *areas;
-            snd_pcm_uframes_t offset, frames = (snd_pcm_uframes_t) n;
+            snd_pcm_uframes_t offset, frames;
             snd_pcm_sframes_t sframes;
 
+            frames = (snd_pcm_uframes_t) (n_bytes / u->frame_size);
 /*             pa_log_debug("%lu frames to write", (unsigned long) frames); */
 
             if (PA_UNLIKELY((err = pa_alsa_safe_mmap_begin(u->pcm_handle, &areas, &offset, &frames, u->hwbuf_size, &u->sink->sample_spec)) < 0)) {
@@ -337,8 +361,6 @@
 
             pa_sink_render_into_full(u->sink, &chunk);
 
-            /* FIXME: Maybe we can do something to keep this memory block
-             * a little bit longer around? */
             pa_memblock_unref_fixed(chunk.memblock);
 
             if (PA_UNLIKELY((sframes = snd_pcm_mmap_commit(u->pcm_handle, offset, frames)) < 0)) {
@@ -349,28 +371,29 @@
                 return r;
             }
 
-            work_done = 1;
+            work_done = TRUE;
 
-            u->frame_index += (int64_t) frames;
+            u->write_count += frames * u->frame_size;
             u->since_start += frames * u->frame_size;
 
 /*             pa_log_debug("wrote %lu frames", (unsigned long) frames); */
 
-            if (frames >= (snd_pcm_uframes_t) n)
+            if ((size_t) frames * u->frame_size >= n_bytes)
                 break;
 
-            n -= (snd_pcm_sframes_t) frames;
+            n_bytes -= (size_t) frames * u->frame_size;
         }
     }
 
     *sleep_usec = pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) - process_usec;
-    return work_done;
+    return work_done ? 1 : 0;
 }
 
 static int unix_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
-    int work_done = 0;
+    pa_bool_t work_done = FALSE;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_play;
+    unsigned j = 0;
 
     pa_assert(u);
     pa_sink_assert_ref(u->sink);
@@ -380,10 +403,9 @@
 
     for (;;) {
         snd_pcm_sframes_t n;
+        size_t n_bytes;
         int r;
 
-        snd_pcm_hwsync(u->pcm_handle);
-
         if (PA_UNLIKELY((n = pa_alsa_safe_avail_update(u->pcm_handle, u->hwbuf_size, &u->sink->sample_spec)) < 0)) {
 
             if ((r = try_recover(u, "snd_pcm_avail_update", (int) n)) == 0)
@@ -392,7 +414,8 @@
             return r;
         }
 
-        left_to_play = check_left_to_play(u, n);
+        n_bytes = (size_t) n * u->frame_size;
+        left_to_play = check_left_to_play(u, n_bytes);
 
         if (u->use_tsched)
 
@@ -406,18 +429,20 @@
                 pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+        if (PA_UNLIKELY(n_bytes <= u->hwbuf_unused)) {
 
             if (u->use_tsched && polled)
-                pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
+                pa_log_debug("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
                        "Most likely this is a Linux bug. Please report this issue to the ALSA developers. "
                        "We were woken up with POLLOUT set -- however a subsequent snd_pcm_avail_update() returned 0.");
 
             break;
         }
 
-        n -= u->hwbuf_unused_frames;
+        if (++j > 10)
+            break;
 
+        n_bytes -= u->hwbuf_unused;
         polled = FALSE;
 
         for (;;) {
@@ -427,14 +452,14 @@
 /*         pa_log_debug("%lu frames to write", (unsigned long) frames); */
 
             if (u->memchunk.length <= 0)
-                pa_sink_render(u->sink, (size_t) n * u->frame_size, &u->memchunk);
+                pa_sink_render(u->sink, n_bytes, &u->memchunk);
 
             pa_assert(u->memchunk.length > 0);
 
             frames = (snd_pcm_sframes_t) (u->memchunk.length / u->frame_size);
 
-            if (frames > n)
-                frames = n;
+            if (frames > (snd_pcm_sframes_t) (n_bytes/u->frame_size))
+                frames = (snd_pcm_sframes_t) (n_bytes/u->frame_size);
 
             p = pa_memblock_acquire(u->memchunk.memblock);
             frames = snd_pcm_writei(u->pcm_handle, (const uint8_t*) p + u->memchunk.index, (snd_pcm_uframes_t) frames);
@@ -458,30 +483,29 @@
                 pa_memchunk_reset(&u->memchunk);
             }
 
-            work_done = 1;
+            work_done = TRUE;
 
-            u->frame_index += frames;
-            u->since_start += (size_t) frames * u->frame_size;
+            u->write_count += frames * u->frame_size;
+            u->since_start += frames * u->frame_size;
 
 /*         pa_log_debug("wrote %lu frames", (unsigned long) frames); */
 
-            if (frames >= n)
+            if ((size_t) frames * u->frame_size >= n_bytes)
                 break;
 
-            n -= frames;
+            n_bytes -= (size_t) frames * u->frame_size;
         }
     }
 
     *sleep_usec = pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) - process_usec;
-    return work_done;
+    return work_done ? 1 : 0;
 }
 
 static void update_smoother(struct userdata *u) {
-    snd_pcm_sframes_t delay  = 0;
-    int64_t frames;
+    snd_pcm_sframes_t delay = 0;
+    int64_t position;
     int err;
-    pa_usec_t now1, now2;
-/*     struct timeval timestamp; */
+    pa_usec_t now1 = 0, now2;
     snd_pcm_status_t *status;
 
     snd_pcm_status_alloca(&status);
@@ -491,36 +515,35 @@
 
     /* Let's update the time smoother */
 
-    snd_pcm_hwsync(u->pcm_handle);
-    snd_pcm_avail_update(u->pcm_handle);
-
-/*     if (PA_UNLIKELY((err = snd_pcm_status(u->pcm_handle, status)) < 0)) { */
-/*         pa_log("Failed to query DSP status data: %s", snd_strerror(err)); */
-/*         return; */
-/*     } */
-
-/*     delay = snd_pcm_status_get_delay(status); */
-
-    if (PA_UNLIKELY((err = snd_pcm_delay(u->pcm_handle, &delay)) < 0)) {
-        pa_log("Failed to query DSP status data: %s", snd_strerror(err));
+    if (PA_UNLIKELY((err = pa_alsa_safe_delay(u->pcm_handle, &delay, u->hwbuf_size, &u->sink->sample_spec)) < 0)) {
+        pa_log_warn("Failed to query DSP status data: %s", snd_strerror(err));
         return;
     }
 
-    frames = u->frame_index - delay;
+    if (PA_UNLIKELY((err = snd_pcm_status(u->pcm_handle, status)) < 0))
+        pa_log_warn("Failed to get timestamp: %s", snd_strerror(err));
+    else {
+        snd_htimestamp_t htstamp = { 0, 0 };
+        snd_pcm_status_get_htstamp(status, &htstamp);
+        now1 = pa_timespec_load(&htstamp);
+    }
+
+    position = (int64_t) u->write_count - ((int64_t) delay * (int64_t) u->frame_size);
 
-/*     pa_log_debug("frame_index = %llu, delay = %llu, p = %llu", (unsigned long long) u->frame_index, (unsigned long long) delay, (unsigned long long) frames); */
+    if (PA_UNLIKELY(position < 0))
+        position = 0;
 
-/*     snd_pcm_status_get_tstamp(status, &timestamp); */
-/*     pa_rtclock_from_wallclock(&timestamp); */
-/*     now1 = pa_timeval_load(&timestamp); */
+    /* Hmm, if the timestamp is 0, then it wasn't set and we take the current time */
+    if (now1 <= 0)
+        now1 = pa_rtclock_usec();
+
+    now2 = pa_bytes_to_usec((uint64_t) position, &u->sink->sample_spec);
 
-    now1 = pa_rtclock_usec();
-    now2 = pa_bytes_to_usec((uint64_t) frames * u->frame_size, &u->sink->sample_spec);
     pa_smoother_put(u->smoother, now1, now2);
 }
 
 static pa_usec_t sink_get_latency(struct userdata *u) {
-    pa_usec_t r = 0;
+    pa_usec_t r;
     int64_t delay;
     pa_usec_t now1, now2;
 
@@ -529,10 +552,9 @@
     now1 = pa_rtclock_usec();
     now2 = pa_smoother_get(u->smoother, now1);
 
-    delay = (int64_t) pa_bytes_to_usec((uint64_t) u->frame_index * u->frame_size, &u->sink->sample_spec) - (int64_t) now2;
+    delay = (int64_t) pa_bytes_to_usec(u->write_count, &u->sink->sample_spec) - (int64_t) now2;
 
-    if (delay > 0)
-        r = (pa_usec_t) delay;
+    r = delay >= 0 ? (pa_usec_t) delay : 0;
 
     if (u->memchunk.memblock)
         r += pa_bytes_to_usec(u->memchunk.length, &u->sink->sample_spec);
@@ -581,7 +603,7 @@
     pa_assert(u);
 
     /* Use the full buffer if noone asked us for anything specific */
-    u->hwbuf_unused_frames = 0;
+    u->hwbuf_unused = 0;
 
     if (u->use_tsched) {
         pa_usec_t latency;
@@ -589,7 +611,7 @@
         if ((latency = pa_sink_get_requested_latency_within_thread(u->sink)) != (pa_usec_t) -1) {
             size_t b;
 
-            pa_log_debug("latency set to %0.2fms", (double) latency / PA_USEC_PER_MSEC);
+            pa_log_debug("Latency set to %0.2fms", (double) latency / PA_USEC_PER_MSEC);
 
             b = pa_usec_to_bytes(latency, &u->sink->sample_spec);
 
@@ -598,18 +620,17 @@
             if (PA_UNLIKELY(b < u->frame_size))
                 b = u->frame_size;
 
-            u->hwbuf_unused_frames = (snd_pcm_sframes_t)
-                (PA_LIKELY(b < u->hwbuf_size) ?
-                 ((u->hwbuf_size - b) / u->frame_size) : 0);
+            u->hwbuf_unused = PA_LIKELY(b < u->hwbuf_size) ? (u->hwbuf_size - b) : 0;
         }
 
+        fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
     }
 
-    pa_log_debug("hwbuf_unused_frames=%lu", (unsigned long) u->hwbuf_unused_frames);
+    pa_log_debug("hwbuf_unused=%lu", (unsigned long) u->hwbuf_unused);
 
     /* We need at last one frame in the used part of the buffer */
-    avail_min = (snd_pcm_uframes_t) u->hwbuf_unused_frames + 1;
+    avail_min = (snd_pcm_uframes_t) u->hwbuf_unused / u->frame_size + 1;
 
     if (u->use_tsched) {
         pa_usec_t sleep_usec, process_usec;
@@ -625,7 +646,7 @@
         return err;
     }
 
-    pa_sink_set_max_request(u->sink, u->hwbuf_size - (size_t) u->hwbuf_unused_frames * u->frame_size);
+    pa_sink_set_max_request(u->sink, u->hwbuf_size - u->hwbuf_unused);
 
     return 0;
 }
@@ -1014,13 +1035,13 @@
 
 static void sink_update_requested_latency_cb(pa_sink *s) {
     struct userdata *u = s->userdata;
-    snd_pcm_sframes_t before;
+    size_t before;
     pa_assert(u);
 
     if (!u->pcm_handle)
         return;
 
-    before = u->hwbuf_unused_frames;
+    before = u->hwbuf_unused;
     update_sw_params(u);
 
     /* Let's check whether we now use only a smaller part of the
@@ -1029,7 +1050,7 @@
     current fill level. Thus, let's do a full rewind once, to clear
     things up. */
 
-    if (u->hwbuf_unused_frames > before) {
+    if (u->hwbuf_unused > before) {
         pa_log_debug("Requesting rewind due to latency change.");
         pa_sink_request_rewind(s, (size_t) -1);
     }
@@ -1084,7 +1105,7 @@
         if (rewind_nbytes <= 0)
             pa_log_info("Tried rewind, but was apparently not possible.");
         else {
-            u->frame_index -= out_frames;
+            u->write_count -= out_frames * u->frame_size;
             pa_log_debug("Rewound %lu bytes.", (unsigned long) rewind_nbytes);
             pa_sink_process_rewind(u->sink, rewind_nbytes);
 
@@ -1165,7 +1186,7 @@
                      * we have filled the buffer at least once
                      * completely.*/
 
-                    /*pa_log_debug("Cutting sleep time for the initial iterations by half.");*/
+                    pa_log_debug("Cutting sleep time for the initial iterations by half.");
                     sleep_usec /= 2;
                 }
 
@@ -1211,7 +1232,7 @@
                 goto fail;
             }
 
-            if (revents & (POLLIN|POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
+            if (revents & ~POLLOUT) {
                 if (pa_alsa_recover_from_poll(u->pcm_handle, revents) < 0)
                     goto fail;
 
@@ -1240,7 +1261,7 @@
     pa_modargs *ma = NULL;
     struct userdata *u = NULL;
     const char *dev_id;
-    pa_sample_spec ss;
+    pa_sample_spec ss, requested_ss;
     pa_channel_map map;
     uint32_t nfrags, hwbuf_size, frag_size, tsched_size, tsched_watermark;
     snd_pcm_uframes_t period_frames, tsched_frames;
@@ -1271,6 +1292,7 @@
         goto fail;
     }
 
+    requested_ss = ss;
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -1314,8 +1336,6 @@
     u->use_mmap = use_mmap;
     u->use_tsched = use_tsched;
     u->first = TRUE;
-    u->since_start = 0;
-    u->after_rewind = FALSE;
     u->rtpoll = pa_rtpoll_new();
     pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
     u->alsa_rtpoll_item = NULL;
@@ -1358,6 +1378,11 @@
     pa_assert(u->device_name);
     pa_log_info("Successfully opened device %s.", u->device_name);
 
+    if (pa_alsa_pcm_is_modem(u->pcm_handle)) {
+        pa_log_notice("Device %s is modem, refusing further initialization.", u->device_name);
+        goto fail;
+    }
+
     if (use_mmap && !b) {
         pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
         u->use_mmap = use_mmap = FALSE;
@@ -1368,6 +1393,11 @@
         u->use_tsched = use_tsched = FALSE;
     }
 
+    if (use_tsched && !pa_alsa_pcm_is_hw(u->pcm_handle)) {
+        pa_log_info("Device is not a hardware device, disabling timer-based scheduling.");
+        u->use_tsched = use_tsched = FALSE;
+    }
+
     if (u->use_mmap)
         pa_log_info("Successfully enabled mmap() mode.");
 
@@ -1461,17 +1491,17 @@
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
-    u->hwbuf_unused_frames = 0;
-    u->tsched_watermark = tsched_watermark;
-    u->frame_index = 0;
+    u->tsched_watermark = pa_usec_to_bytes_round_up(pa_bytes_to_usec_round_up(tsched_watermark, &requested_ss), &u->sink->sample_spec);
     u->hw_dB_supported = FALSE;
     u->hw_dB_min = u->hw_dB_max = 0;
     u->hw_volume_min = u->hw_volume_max = 0;
     u->mixer_seperate_channels = FALSE;
     pa_cvolume_mute(&u->hardware_volume, u->sink->sample_spec.channels);
 
-    if (use_tsched)
+    if (use_tsched) {
+        fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
+    }
 
     u->sink->thread_info.max_rewind = use_tsched ? u->hwbuf_size : 0;
     u->sink->thread_info.max_request = u->hwbuf_size;
Index: pulseaudio-0.9.14/src/modules/module-alsa-source.c
===================================================================
--- pulseaudio-0.9.14.orig/src/modules/module-alsa-source.c	2009-04-07 20:17:53.000000000 -0400
+++ pulseaudio-0.9.14/src/modules/module-alsa-source.c	2009-04-07 20:22:00.000000000 -0400
@@ -95,8 +95,8 @@
 #define DEFAULT_DEVICE "default"
 #define DEFAULT_TSCHED_BUFFER_USEC (2*PA_USEC_PER_SEC)       /* 2s */
 #define DEFAULT_TSCHED_WATERMARK_USEC (20*PA_USEC_PER_MSEC)  /* 20ms */
-#define TSCHED_MIN_SLEEP_USEC (3*PA_USEC_PER_MSEC)           /* 3ms */
-#define TSCHED_MIN_WAKEUP_USEC (3*PA_USEC_PER_MSEC)          /* 3ms */
+#define TSCHED_MIN_SLEEP_USEC (10*PA_USEC_PER_MSEC)          /* 10ms */
+#define TSCHED_MIN_WAKEUP_USEC (4*PA_USEC_PER_MSEC)          /* 4ms */
 
 struct userdata {
     pa_core *core;
@@ -119,7 +119,7 @@
 
     pa_cvolume hardware_volume;
 
-    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark;
+    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark, hwbuf_unused, min_sleep, min_wakeup;
     unsigned nfragments;
 
     char *device_name;
@@ -131,36 +131,63 @@
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
 
     pa_smoother *smoother;
-    int64_t frame_index;
-
-    snd_pcm_sframes_t hwbuf_unused_frames;
+    uint64_t read_count;
 };
 
+static void fix_min_sleep_wakeup(struct userdata *u) {
+    size_t max_use, max_use_2;
+    pa_assert(u);
+
+    max_use = u->hwbuf_size - u->hwbuf_unused;
+    max_use_2 = pa_frame_align(max_use/2, &u->source->sample_spec);
+
+    u->min_sleep = pa_usec_to_bytes(TSCHED_MIN_SLEEP_USEC, &u->source->sample_spec);
+    u->min_sleep = PA_CLAMP(u->min_sleep, u->frame_size, max_use_2);
+
+    u->min_wakeup = pa_usec_to_bytes(TSCHED_MIN_WAKEUP_USEC, &u->source->sample_spec);
+    u->min_wakeup = PA_CLAMP(u->min_wakeup, u->frame_size, max_use_2);
+}
+
 static void fix_tsched_watermark(struct userdata *u) {
     size_t max_use;
-    size_t min_sleep, min_wakeup;
     pa_assert(u);
 
-    max_use = u->hwbuf_size - (size_t) u->hwbuf_unused_frames * u->frame_size;
+    max_use = u->hwbuf_size - u->hwbuf_unused;
 
-    min_sleep = pa_usec_to_bytes(TSCHED_MIN_SLEEP_USEC, &u->source->sample_spec);
-    min_wakeup = pa_usec_to_bytes(TSCHED_MIN_WAKEUP_USEC, &u->source->sample_spec);
+    if (u->tsched_watermark > max_use - u->min_sleep)
+        u->tsched_watermark = max_use - u->min_sleep;
 
-    if (min_sleep > max_use/2)
-        min_sleep = pa_frame_align(max_use/2, &u->source->sample_spec);
-    if (min_sleep < u->frame_size)
-        min_sleep = u->frame_size;
-
-    if (min_wakeup > max_use/2)
-        min_wakeup = pa_frame_align(max_use/2, &u->source->sample_spec);
-    if (min_wakeup < u->frame_size)
-        min_wakeup = u->frame_size;
+    if (u->tsched_watermark < u->min_wakeup)
+        u->tsched_watermark = u->min_wakeup;
+}
+
+static void adjust_after_overrun(struct userdata *u) {
+    size_t old_watermark;
+    pa_usec_t old_min_latency, new_min_latency;
 
-    if (u->tsched_watermark > max_use-min_sleep)
-        u->tsched_watermark = max_use-min_sleep;
+    pa_assert(u);
 
-    if (u->tsched_watermark < min_wakeup)
-        u->tsched_watermark = min_wakeup;
+    /* First, just try to increase the watermark */
+    old_watermark = u->tsched_watermark;
+    u->tsched_watermark *= 2;
+    fix_tsched_watermark(u);
+
+    if (old_watermark != u->tsched_watermark) {
+        pa_log_notice("Increasing wakeup watermark to %0.2f ms",
+                      (double) pa_bytes_to_usec(u->tsched_watermark, &u->source->sample_spec) / PA_USEC_PER_MSEC);
+        return;
+    }
+
+    /* Hmm, we cannot increase the watermark any further, hence let's raise the latency */
+    old_min_latency = u->source->thread_info.min_latency;
+    new_min_latency = PA_MIN(old_min_latency * 2, u->source->thread_info.max_latency);
+
+    if (old_min_latency != new_min_latency) {
+        pa_log_notice("Increasing minimal latency to %0.2f ms",
+                      (double) new_min_latency / PA_USEC_PER_MSEC);
+        pa_source_update_latency_range(u->source, new_min_latency, u->source->thread_info.max_latency);
+        return;
+    }
 }
 
 static pa_usec_t hw_sleep_time(struct userdata *u, pa_usec_t *sleep_usec, pa_usec_t*process_usec) {
@@ -173,17 +200,13 @@
     if (usec == (pa_usec_t) -1)
         usec = pa_bytes_to_usec(u->hwbuf_size, &u->source->sample_spec);
 
-/*     pa_log_debug("hw buffer time: %u ms", (unsigned) (usec / PA_USEC_PER_MSEC)); */
-
     wm = pa_bytes_to_usec(u->tsched_watermark, &u->source->sample_spec);
 
-    if (usec >= wm) {
-        *sleep_usec = usec - wm;
-        *process_usec = wm;
-    } else
-        *process_usec = *sleep_usec = usec /= 2;
+    if (wm > usec)
+        wm = usec/2;
 
-/*     pa_log_debug("after watermark: %u ms", (unsigned) (*sleep_usec / PA_USEC_PER_MSEC)); */
+    *sleep_usec = usec - wm;
+    *process_usec = wm;
 
     return usec;
 }
@@ -200,48 +223,42 @@
     if (err == -EPIPE)
         pa_log_debug("%s: Buffer overrun!", call);
 
-    if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0) {
-        snd_pcm_start(u->pcm_handle);
-        return 0;
+    if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) < 0) {
+        pa_log("%s: %s", call, snd_strerror(err));
+        return -1;
     }
 
-    pa_log("%s: %s", call, snd_strerror(err));
-    return -1;
+    snd_pcm_start(u->pcm_handle);
+    return 0;
 }
 
-static size_t check_left_to_record(struct userdata *u, snd_pcm_sframes_t n) {
+static size_t check_left_to_record(struct userdata *u, size_t n_bytes) {
     size_t left_to_record;
-    size_t rec_space = u->hwbuf_size - (size_t) u->hwbuf_unused_frames*u->frame_size;
+    size_t rec_space = u->hwbuf_size - u->hwbuf_unused;
 
-    if ((size_t) n*u->frame_size < rec_space)
-        left_to_record = rec_space - ((size_t) n*u->frame_size);
-    else
-        left_to_record = 0;
+    /* We use <= instead of < for this check here because an overrun
+     * only happens after the last sample was processed, not already when
+     * it is removed from the buffer. This is particularly important
+     * when block transfer is used. */
 
-    if (left_to_record > 0) {
-/*         pa_log_debug("%0.2f ms left to record", (double) pa_bytes_to_usec(left_to_record, &u->source->sample_spec) / PA_USEC_PER_MSEC); */
-    } else {
+    if (n_bytes <= rec_space)
+        left_to_record = rec_space - n_bytes;
+    else {
+        left_to_record = 0;
         pa_log_info("Overrun!");
 
-        if (u->use_tsched) {
-            size_t old_watermark = u->tsched_watermark;
-
-            u->tsched_watermark *= 2;
-            fix_tsched_watermark(u);
-
-            if (old_watermark != u->tsched_watermark)
-                pa_log_notice("Increasing wakeup watermark to %0.2f ms",
-                              (double) pa_bytes_to_usec(u->tsched_watermark, &u->source->sample_spec) / PA_USEC_PER_MSEC);
-        }
+        if (u->use_tsched)
+            adjust_after_overrun(u);
     }
 
     return left_to_record;
 }
 
 static int mmap_read(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
-    int work_done = 0;
+    pa_bool_t work_done = FALSE;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_record;
+    unsigned j = 0;
 
     pa_assert(u);
     pa_source_assert_ref(u->source);
@@ -251,10 +268,9 @@
 
     for (;;) {
         snd_pcm_sframes_t n;
+        size_t n_bytes;
         int r;
 
-        snd_pcm_hwsync(u->pcm_handle);
-
         if (PA_UNLIKELY((n = pa_alsa_safe_avail_update(u->pcm_handle, u->hwbuf_size, &u->source->sample_spec)) < 0)) {
 
             if ((r = try_recover(u, "snd_pcm_avail_update", (int) n)) == 0)
@@ -263,33 +279,38 @@
             return r;
         }
 
-        left_to_record = check_left_to_record(u, n);
+        n_bytes = (size_t) n * u->frame_size;
+        left_to_record = check_left_to_record(u, n_bytes);
 
         if (u->use_tsched)
             if (!polled &&
                 pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= 0)) {
+        if (PA_UNLIKELY(n_bytes <= 0)) {
 
             if (u->use_tsched && polled)
-                pa_log("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
+                pa_log_debug("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
                        "Most likely this is a Linux bug. Please report this issue to the ALSA developers. "
                        "We were woken up with POLLIN set -- however a subsequent snd_pcm_avail_update() returned 0.");
 
             break;
         }
 
+        if (++j > 10)
+            break;
+
         polled = FALSE;
 
         for (;;) {
             int err;
             const snd_pcm_channel_area_t *areas;
-            snd_pcm_uframes_t offset, frames = (snd_pcm_uframes_t) n;
+            snd_pcm_uframes_t offset, frames;
             pa_memchunk chunk;
             void *p;
             snd_pcm_sframes_t sframes;
 
+            frames = (snd_pcm_uframes_t) (n_bytes / u->frame_size);
 /*             pa_log_debug("%lu frames to read", (unsigned long) frames); */
 
             if (PA_UNLIKELY((err = pa_alsa_safe_mmap_begin(u->pcm_handle, &areas, &offset, &frames, u->hwbuf_size, &u->source->sample_spec)) < 0)) {
@@ -329,27 +350,28 @@
                 return r;
             }
 
-            work_done = 1;
+            work_done = TRUE;
 
-            u->frame_index += (int64_t) frames;
+            u->read_count += frames * u->frame_size;
 
 /*             pa_log_debug("read %lu frames", (unsigned long) frames); */
 
-            if (frames >= (snd_pcm_uframes_t) n)
+            if ((size_t) frames * u->frame_size >= n_bytes)
                 break;
 
-            n -= (snd_pcm_sframes_t) frames;
+            n_bytes -= (size_t) frames * u->frame_size;
         }
     }
 
     *sleep_usec = pa_bytes_to_usec(left_to_record, &u->source->sample_spec) - process_usec;
-    return work_done;
+    return work_done ? 1 : 0;
 }
 
 static int unix_read(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
-    int work_done = 0;
+    pa_bool_t work_done = FALSE;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_record;
+    unsigned j = 0;
 
     pa_assert(u);
     pa_source_assert_ref(u->source);
@@ -359,10 +381,9 @@
 
     for (;;) {
         snd_pcm_sframes_t n;
+        size_t n_bytes;
         int r;
 
-        snd_pcm_hwsync(u->pcm_handle);
-
         if (PA_UNLIKELY((n = pa_alsa_safe_avail_update(u->pcm_handle, u->hwbuf_size, &u->source->sample_spec)) < 0)) {
 
             if ((r = try_recover(u, "snd_pcm_avail_update", (int) n)) == 0)
@@ -371,23 +392,27 @@
             return r;
         }
 
-        left_to_record = check_left_to_record(u, n);
+        n_bytes = (size_t) n * u->frame_size;
+        left_to_record = check_left_to_record(u, n_bytes);
 
         if (u->use_tsched)
             if (!polled &&
                 pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= 0)) {
+        if (PA_UNLIKELY(n_bytes <= 0)) {
 
             if (u->use_tsched && polled)
-                pa_log("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
+                pa_log_debug("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
                        "Most likely this is a Linux bug. Please report this issue to the ALSA developers. "
                        "We were woken up with POLLIN set -- however a subsequent snd_pcm_avail_update() returned 0.");
 
-            return work_done;
+            break;
         }
 
+        if (++j > 10)
+            break;
+
         polled = FALSE;
 
         for (;;) {
@@ -399,8 +424,8 @@
 
             frames = (snd_pcm_sframes_t) (pa_memblock_get_length(chunk.memblock) / u->frame_size);
 
-            if (frames > n)
-                frames = n;
+            if (frames > (snd_pcm_sframes_t) (n_bytes/u->frame_size))
+                frames = (snd_pcm_sframes_t) (n_bytes/u->frame_size);
 
 /*             pa_log_debug("%lu frames to read", (unsigned long) n); */
 
@@ -425,52 +450,62 @@
             pa_source_post(u->source, &chunk);
             pa_memblock_unref(chunk.memblock);
 
-            work_done = 1;
+            work_done = TRUE;
 
-            u->frame_index += frames;
+            u->read_count += frames * u->frame_size;
 
 /*             pa_log_debug("read %lu frames", (unsigned long) frames); */
 
-            if (frames >= n)
+            if ((size_t) frames * u->frame_size >= n_bytes)
                 break;
 
-            n -= frames;
+            n_bytes -= (size_t) frames * u->frame_size;
         }
     }
 
     *sleep_usec = pa_bytes_to_usec(left_to_record, &u->source->sample_spec) - process_usec;
-    return work_done;
+    return work_done ? 1 : 0;
 }
 
 static void update_smoother(struct userdata *u) {
     snd_pcm_sframes_t delay = 0;
-    int64_t frames;
+    uint64_t position;
     int err;
-    pa_usec_t now1, now2;
+    pa_usec_t now1 = 0, now2;
+    snd_pcm_status_t *status;
+
+    snd_pcm_status_alloca(&status);
 
     pa_assert(u);
     pa_assert(u->pcm_handle);
 
     /* Let's update the time smoother */
 
-    snd_pcm_hwsync(u->pcm_handle);
-    snd_pcm_avail_update(u->pcm_handle);
-
-    if (PA_UNLIKELY((err = snd_pcm_delay(u->pcm_handle, &delay)) < 0)) {
+    if (PA_UNLIKELY((err = pa_alsa_safe_delay(u->pcm_handle, &delay, u->hwbuf_size, &u->source->sample_spec)) < 0)) {
         pa_log_warn("Failed to get delay: %s", snd_strerror(err));
         return;
     }
 
-    frames = u->frame_index + delay;
+    if (PA_UNLIKELY((err = snd_pcm_status(u->pcm_handle, status)) < 0))
+        pa_log_warn("Failed to get timestamp: %s", snd_strerror(err));
+    else {
+        snd_htimestamp_t htstamp = { 0, 0 };
+        snd_pcm_status_get_htstamp(status, &htstamp);
+        now1 = pa_timespec_load(&htstamp);
+    }
 
-    now1 = pa_rtclock_usec();
-    now2 = pa_bytes_to_usec((uint64_t) frames * u->frame_size, &u->source->sample_spec);
+    position = u->read_count + ((uint64_t) delay * (uint64_t) u->frame_size);
+
+    /* Hmm, if the timestamp is 0, then it wasn't set and we take the current time */
+    if (now1 <= 0)
+        now1 = pa_rtclock_usec();
+
+    now2 = pa_bytes_to_usec(position, &u->source->sample_spec);
 
     pa_smoother_put(u->smoother, now1, now2);
 }
 
 static pa_usec_t source_get_latency(struct userdata *u) {
-    pa_usec_t r = 0;
     int64_t delay;
     pa_usec_t now1, now2;
 
@@ -479,12 +514,9 @@
     now1 = pa_rtclock_usec();
     now2 = pa_smoother_get(u->smoother, now1);
 
-    delay = (int64_t) now2 - (int64_t) pa_bytes_to_usec((uint64_t) u->frame_index * u->frame_size, &u->source->sample_spec);
-
-    if (delay > 0)
-        r = (pa_usec_t) delay;
+    delay = (int64_t) now2 - (int64_t) pa_bytes_to_usec(u->read_count, &u->source->sample_spec);
 
-    return r;
+    return delay >= 0 ? (pa_usec_t) delay : 0;
 }
 
 static int build_pollfd(struct userdata *u) {
@@ -527,7 +559,7 @@
     pa_assert(u);
 
     /* Use the full buffer if noone asked us for anything specific */
-    u->hwbuf_unused_frames = 0;
+    u->hwbuf_unused = 0;
 
     if (u->use_tsched) {
         pa_usec_t latency;
@@ -544,15 +576,14 @@
             if (PA_UNLIKELY(b < u->frame_size))
                 b = u->frame_size;
 
-            u->hwbuf_unused_frames = (snd_pcm_sframes_t)
-                (PA_LIKELY(b < u->hwbuf_size) ?
-                 ((u->hwbuf_size - b) / u->frame_size) : 0);
+            u->hwbuf_unused = PA_LIKELY(b < u->hwbuf_size) ? (u->hwbuf_size - b) : 0;
         }
 
+        fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
     }
 
-    pa_log_debug("hwbuf_unused_frames=%lu", (unsigned long) u->hwbuf_unused_frames);
+    pa_log_debug("hwbuf_unused=%lu", (unsigned long) u->hwbuf_unused);
 
     avail_min = 1;
 
@@ -989,7 +1020,7 @@
 
         /* Read some data and pass it to the sources */
         if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
-            int work_done = 0;
+            int work_done;
             pa_usec_t sleep_usec = 0;
 
             if (u->use_mmap)
@@ -1047,7 +1078,7 @@
                 goto fail;
             }
 
-            if (revents & (POLLOUT|POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
+            if (revents & ~POLLIN) {
                 if (pa_alsa_recover_from_poll(u->pcm_handle, revents) < 0)
                     goto fail;
 
@@ -1075,7 +1106,7 @@
     pa_modargs *ma = NULL;
     struct userdata *u = NULL;
     const char *dev_id;
-    pa_sample_spec ss;
+    pa_sample_spec ss, requested_ss;
     pa_channel_map map;
     uint32_t nfrags, hwbuf_size, frag_size, tsched_size, tsched_watermark;
     snd_pcm_uframes_t period_frames, tsched_frames;
@@ -1105,6 +1136,7 @@
         goto fail;
     }
 
+    requested_ss = ss;
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -1151,7 +1183,7 @@
     pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
     u->alsa_rtpoll_item = NULL;
 
-    u->smoother = pa_smoother_new(DEFAULT_TSCHED_WATERMARK_USEC, DEFAULT_TSCHED_WATERMARK_USEC, TRUE, 5);
+    u->smoother = pa_smoother_new(DEFAULT_TSCHED_WATERMARK_USEC*2, DEFAULT_TSCHED_WATERMARK_USEC*2, TRUE, 5);
     pa_smoother_set_time_offset(u->smoother, pa_rtclock_usec());
 
     snd_config_update_free_global();
@@ -1185,6 +1217,11 @@
     pa_assert(u->device_name);
     pa_log_info("Successfully opened device %s.", u->device_name);
 
+    if (pa_alsa_pcm_is_modem(u->pcm_handle)) {
+        pa_log_notice("Device %s is modem, refusing further initialization.", u->device_name);
+        goto fail;
+    }
+
     if (use_mmap && !b) {
         pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
         u->use_mmap = use_mmap = FALSE;
@@ -1195,6 +1232,11 @@
         u->use_tsched = use_tsched = FALSE;
     }
 
+    if (use_tsched && !pa_alsa_pcm_is_hw(u->pcm_handle)) {
+        pa_log_info("Device is not a hardware device, disabling timer-based scheduling.");
+        u->use_tsched = use_tsched = FALSE;
+    }
+
     if (u->use_mmap)
         pa_log_info("Successfully enabled mmap() mode.");
 
@@ -1288,17 +1330,17 @@
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
-    u->hwbuf_unused_frames = 0;
-    u->tsched_watermark = tsched_watermark;
-    u->frame_index = 0;
+    u->tsched_watermark = pa_usec_to_bytes_round_up(pa_bytes_to_usec_round_up(tsched_watermark, &requested_ss), &u->source->sample_spec);
     u->hw_dB_supported = FALSE;
     u->hw_dB_min = u->hw_dB_max = 0;
     u->hw_volume_min = u->hw_volume_max = 0;
     u->mixer_seperate_channels = FALSE;
     pa_cvolume_mute(&u->hardware_volume, u->source->sample_spec.channels);
 
-    if (use_tsched)
+    if (use_tsched) {
+        fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
+    }
 
     pa_source_set_latency_range(u->source,
                                 !use_tsched ? pa_bytes_to_usec(u->hwbuf_size, &ss) : (pa_usec_t) -1,
Index: pulseaudio-0.9.14/src/modules/alsa-util.c
===================================================================
--- pulseaudio-0.9.14.orig/src/modules/alsa-util.c	2009-04-07 20:17:53.000000000 -0400
+++ pulseaudio-0.9.14/src/modules/alsa-util.c	2009-04-07 20:22:43.000000000 -0400
@@ -442,6 +442,7 @@
 
 int pa_alsa_set_sw_params(snd_pcm_t *pcm, snd_pcm_uframes_t avail_min) {
     snd_pcm_sw_params_t *swparams;
+    snd_pcm_uframes_t boundary;
     int err;
 
     pa_assert(pcm);
@@ -453,7 +454,22 @@
         return err;
     }
 
-    if ((err = snd_pcm_sw_params_set_stop_threshold(pcm, swparams, (snd_pcm_uframes_t) -1)) < 0) {
+    if ((err = snd_pcm_sw_params_set_period_event(pcm, swparams, 0)) < 0) {
+        pa_log_warn("Unable to disable period event: %s\n", snd_strerror(err));
+        return err;
+    }
+
+    if ((err = snd_pcm_sw_params_set_tstamp_mode(pcm, swparams, SND_PCM_TSTAMP_ENABLE)) < 0) {
+        pa_log_warn("Unable to enable time stamping: %s\n", snd_strerror(err));
+        return err;
+    }
+
+    if ((err = snd_pcm_sw_params_get_boundary(swparams, &boundary)) < 0) {
+        pa_log_warn("Unable to get boundary: %s\n", snd_strerror(err));
+        return err;
+    }
+
+    if ((err = snd_pcm_sw_params_set_stop_threshold(pcm, swparams, boundary)) < 0) {
         pa_log_warn("Unable to set stop threshold: %s\n", snd_strerror(err));
         return err;
     }
@@ -1228,15 +1244,51 @@
 
     k = (size_t) n * pa_frame_size(ss);
 
-    if (k >= hwbuf_size * 3 ||
-        k >= pa_bytes_per_second(ss)*10)
-        pa_log("snd_pcm_avail_update() returned a value that is exceptionally large: %lu bytes (%lu ms) "
+    if (k >= hwbuf_size * 5 ||
+        k >= pa_bytes_per_second(ss)*10) {
+        pa_log_debug("snd_pcm_avail_update() returned a value that is exceptionally large: %lu bytes (%lu ms) "
                "Most likely this is a Linux bug. Please report this issue to the ALSA developers.",
                (unsigned long) k, (unsigned long) (pa_bytes_to_usec(k, ss) / PA_USEC_PER_MSEC));
+        /* Mhmm, let's try not to fail completely */
+        n = (snd_pcm_sframes_t) (hwbuf_size / pa_frame_size(ss));
+    }
 
     return n;
 }
 
+int pa_alsa_safe_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delay, size_t hwbuf_size, const pa_sample_spec *ss) {
+    ssize_t k;
+    size_t abs_k;
+    int r;
+
+    pa_assert(pcm);
+    pa_assert(delay);
+    pa_assert(hwbuf_size > 0);
+    pa_assert(ss);
+
+    /* Some ALSA driver expose weird bugs, let's inform the user about
+     * what is going on */
+
+    if ((r = snd_pcm_delay(pcm, delay)) < 0)
+        return r;
+
+    k = (ssize_t) *delay * (ssize_t) pa_frame_size(ss);
+
+    abs_k = k >= 0 ? (size_t) k : (size_t) -k;
+
+    if (abs_k >= hwbuf_size * 5 ||
+        abs_k >= pa_bytes_per_second(ss)*10) {
+
+        /* Mhmm, let's try not to fail completely */
+        if (k < 0)
+            *delay = -(snd_pcm_sframes_t) (hwbuf_size / pa_frame_size(ss));
+        else
+            *delay = (snd_pcm_sframes_t) (hwbuf_size / pa_frame_size(ss));
+    }
+
+    return 0;
+}
+
 int pa_alsa_safe_mmap_begin(snd_pcm_t *pcm, const snd_pcm_channel_area_t **areas, snd_pcm_uframes_t *offset, snd_pcm_uframes_t *frames, size_t hwbuf_size, const pa_sample_spec *ss) {
     int r;
     snd_pcm_uframes_t before;
@@ -1262,9 +1314,33 @@
         k >= hwbuf_size * 3 ||
         k >= pa_bytes_per_second(ss)*10)
 
-        pa_log("snd_pcm_mmap_begin() returned a value that is exceptionally large: %lu bytes (%lu ms) "
+        pa_log_debug("snd_pcm_mmap_begin() returned a value that is exceptionally large: %lu bytes (%lu ms) "
                "Most likely this is a Linux bug. Please report this issue to the ALSA developers.",
                (unsigned long) k, (unsigned long) (pa_bytes_to_usec(k, ss) / PA_USEC_PER_MSEC));
 
     return r;
 }
+
+pa_bool_t pa_alsa_pcm_is_hw(snd_pcm_t *pcm) {
+    snd_pcm_info_t* info;
+    snd_pcm_info_alloca(&info);
+
+    pa_assert(pcm);
+
+    if (snd_pcm_info(pcm, info) < 0)
+        return FALSE;
+
+    return snd_pcm_info_get_card(info) >= 0;
+}
+
+pa_bool_t pa_alsa_pcm_is_modem(snd_pcm_t *pcm) {
+    snd_pcm_info_t* info;
+    snd_pcm_info_alloca(&info);
+
+    pa_assert(pcm);
+
+    if (snd_pcm_info(pcm, info) < 0)
+        return FALSE;
+
+    return snd_pcm_info_get_class(info) == SND_PCM_CLASS_MODEM;
+}
Index: pulseaudio-0.9.14/src/modules/alsa-util.h
===================================================================
--- pulseaudio-0.9.14.orig/src/modules/alsa-util.h	2009-04-07 20:17:53.000000000 -0400
+++ pulseaudio-0.9.14/src/modules/alsa-util.h	2009-04-07 20:22:55.000000000 -0400
@@ -93,6 +93,11 @@
 pa_rtpoll_item* pa_alsa_build_pollfd(snd_pcm_t *pcm, pa_rtpoll *rtpoll);
 
 snd_pcm_sframes_t pa_alsa_safe_avail_update(snd_pcm_t *pcm, size_t hwbuf_size, const pa_sample_spec *ss);
+int pa_alsa_safe_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delay, size_t hwbuf_size, const pa_sample_spec *ss);
 int pa_alsa_safe_mmap_begin(snd_pcm_t *pcm, const snd_pcm_channel_area_t **areas, snd_pcm_uframes_t *offset, snd_pcm_uframes_t *frames, size_t hwbuf_size, const pa_sample_spec *ss);
 
+pa_bool_t pa_alsa_pcm_is_hw(snd_pcm_t *pcm);
+
+pa_bool_t pa_alsa_pcm_is_modem(snd_pcm_t *pcm);
+
 #endif
Index: pulseaudio-0.9.14/src/pulsecore/rtclock.c
===================================================================
--- pulseaudio-0.9.14.orig/src/pulsecore/rtclock.c	2009-04-07 20:16:13.000000000 -0400
+++ pulseaudio-0.9.14/src/pulsecore/rtclock.c	2009-04-07 20:17:54.000000000 -0400
@@ -115,3 +115,11 @@
 
     return tv;
 }
+
+pa_usec_t pa_timespec_load(const struct timespec *ts) {
+    pa_assert(ts);
+
+    return
+        (pa_usec_t) ts->tv_sec * PA_USEC_PER_SEC +
+        (pa_usec_t) ts->tv_nsec / PA_NSEC_PER_USEC;
+}
Index: pulseaudio-0.9.14/src/pulsecore/rtclock.h
===================================================================
--- pulseaudio-0.9.14.orig/src/pulsecore/rtclock.h	2009-04-07 20:16:13.000000000 -0400
+++ pulseaudio-0.9.14/src/pulsecore/rtclock.h	2009-04-07 20:17:54.000000000 -0400
@@ -41,4 +41,6 @@
 
 struct timeval* pa_rtclock_from_wallclock(struct timeval *tv);
 
+pa_usec_t pa_timespec_load(const struct timespec *ts);
+
 #endif
