From 411af6b61aa564907d65fad1893383a4eb0a4933 Mon Sep 17 00:00:00 2001
From: Tanu Kaskinen <tanu.kaskinen@digia.com>
Date: Thu, 29 Sep 2011 18:54:01 +0300
Subject: [PATCH 109/125] sink: Move updating the requested latency after the
 rewind request when finishing a stream move.

---
 src/pulsecore/sink.c |   29 +++++++++++++++++++++++------
 1 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index 05b08aa..a2642b4 100644
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -2330,6 +2330,18 @@ int pa_sink_process_msg(pa_msgobject *o, int code, void *userdata, int64_t offse
              * slow start, i.e. need some time to buffer client
              * samples before beginning streaming. */
 
+            /* FIXME: Actually rewinding should be requested before
+             * updating the sink requested latency, because updating
+             * the requested latency updates also max_rewind of the
+             * sink. Now consider this: a sink has a 10 s buffer and
+             * nobody has requested anything less. Then a new stream
+             * appears while the sink buffer is full. The new stream
+             * requests e.g. 100 ms latency. That request is forwarded
+             * to the sink, so now max_rewind is 100 ms. When a rewind
+             * is requested, the sink will only rewind 100 ms, and the
+             * new stream will have to wait about 10 seconds before it
+             * becomes audible. */
+
             /* In flat volume mode we need to update the volume as
              * well */
             return o->process_msg(o, PA_SINK_MESSAGE_SET_SHARED_VOLUME, NULL, 0, NULL);
@@ -2440,12 +2452,6 @@ int pa_sink_process_msg(pa_msgobject *o, int code, void *userdata, int64_t offse
             if (i->attach)
                 i->attach(i);
 
-            if (i->thread_info.requested_sink_latency != (pa_usec_t) -1)
-                pa_sink_input_set_requested_latency_within_thread(i, i->thread_info.requested_sink_latency);
-
-            pa_sink_input_update_max_rewind(i, s->thread_info.max_rewind);
-            pa_sink_input_update_max_request(i, s->thread_info.max_request);
-
             if (i->thread_info.state != PA_SINK_INPUT_CORKED) {
                 pa_usec_t usec = 0;
                 size_t nbytes;
@@ -2461,6 +2467,17 @@ int pa_sink_process_msg(pa_msgobject *o, int code, void *userdata, int64_t offse
                 pa_sink_request_rewind(s, nbytes);
             }
 
+            /* Updating the requested sink latency has to be done
+             * after the sink rewind request, not before, because
+             * otherwise the sink may limit the rewind amount
+             * needlessly. */
+
+            if (i->thread_info.requested_sink_latency != (pa_usec_t) -1)
+                pa_sink_input_set_requested_latency_within_thread(i, i->thread_info.requested_sink_latency);
+
+            pa_sink_input_update_max_rewind(i, s->thread_info.max_rewind);
+            pa_sink_input_update_max_request(i, s->thread_info.max_request);
+
             return o->process_msg(o, PA_SINK_MESSAGE_SET_SHARED_VOLUME, NULL, 0, NULL);
         }
 
-- 
1.7.5.4

