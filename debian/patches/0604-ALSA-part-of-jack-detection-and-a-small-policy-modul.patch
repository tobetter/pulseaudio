From 333d932fd27c5fd5e4d1c2da61677968639161fb Mon Sep 17 00:00:00 2001
From: David Henningsson <david.henningsson@canonical.com>
Date: Wed, 10 Aug 2011 13:56:50 +0200
Subject: [PATCH] ALSA part of jack detection, and a small policy module

Signed-off-by: David Henningsson <david.henningsson@canonical.com>
---
 src/Makefile.am                                    |    1 +
 src/daemon/default.pa.in                           |    2 +
 src/modules/alsa/alsa-jack-inputdev.c              |  397 ++++++++++++++++++++
 src/modules/alsa/alsa-jack-inputdev.h              |   32 ++
 src/modules/alsa/alsa-mixer.c                      |   34 ++
 src/modules/alsa/alsa-mixer.h                      |    4 +
 src/modules/alsa/mixer/paths/analog-input-aux.conf |    2 +-
 .../alsa/mixer/paths/analog-input-dock-mic.conf    |    6 +-
 .../alsa/mixer/paths/analog-input-front-mic.conf   |    6 +-
 .../alsa/mixer/paths/analog-input-linein.conf      |    2 +-
 .../alsa/mixer/paths/analog-input-mic-line.conf    |    2 +-
 src/modules/alsa/mixer/paths/analog-input-mic.conf |    5 +-
 .../alsa/mixer/paths/analog-input-rear-mic.conf    |    6 +-
 .../alsa/mixer/paths/analog-output-headphones.conf |    3 +
 src/modules/alsa/module-alsa-card.c                |   56 +++-
 src/modules/module-switch-on-connect.c             |  138 +++++++-
 src/pulsecore/card.c                               |    4 +
 src/pulsecore/card.h                               |    4 +
 src/pulsecore/core.h                               |    1 +
 src/pulsecore/device-port.c                        |    9 +
 src/pulsecore/device-port.h                        |    2 +
 21 files changed, 705 insertions(+), 11 deletions(-)
 create mode 100644 src/modules/alsa/alsa-jack-inputdev.c
 create mode 100644 src/modules/alsa/alsa-jack-inputdev.h

diff --git a/src/Makefile.am b/src/Makefile.am
index 769a24d..0bd9b1f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1543,6 +1543,7 @@ module_coreaudio_device_la_LIBADD = $(MODULE_LIBADD)
 libalsa_util_la_SOURCES = \
 		modules/alsa/alsa-util.c modules/alsa/alsa-util.h \
 		modules/alsa/alsa-mixer.c modules/alsa/alsa-mixer.h \
+		modules/alsa/alsa-jack-inputdev.c modules/alsa/alsa-jack-inputdev.h \
 		modules/alsa/alsa-sink.c modules/alsa/alsa-sink.h \
 		modules/alsa/alsa-source.c modules/alsa/alsa-source.h \
 		modules/reserve-wrap.c modules/reserve-wrap.h
diff --git a/src/daemon/default.pa.in b/src/daemon/default.pa.in
index 605f42c..e5dceaf 100755
--- a/src/daemon/default.pa.in
+++ b/src/daemon/default.pa.in
@@ -174,3 +174,5 @@ ifelse(@HAVE_X11@, 1, [dnl
 ### Make some devices default
 #set-default-sink output
 #set-default-source input
+
+load-module module-switch-on-connect
diff --git a/src/modules/alsa/alsa-jack-inputdev.c b/src/modules/alsa/alsa-jack-inputdev.c
new file mode 100644
index 0000000..6b5a020
--- /dev/null
+++ b/src/modules/alsa/alsa-jack-inputdev.c
@@ -0,0 +1,397 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2011 Canonical Ltd
+  Copyright 2011 Wolfson Microelectronics PLC
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2.1 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "alsa-jack-inputdev.h"
+#include "alsa-mixer.h"
+#include <libudev.h>
+#include <linux/input.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/strlist.h>
+#include <pulsecore/card.h>
+#include <pulsecore/core.h>
+#include <pulse/xmalloc.h>
+
+struct port_controlinfo {
+    pa_device_port *port;
+    int64_t switches_enable;
+};
+
+struct jack_inputdev {
+    int fd;
+    pa_io_event* io_event;
+    pa_core* core;
+    int64_t switches_supported;
+    char *devname;
+    pa_hashmap *port_controls; /* Has struct port_controlinfo pointers in it */
+};
+
+/* (mostly) from slimlogic/wolfson start */
+
+static const char *jack_get_input_id(const char *path) {
+    int i;
+
+    for( i = 0; i < (int) strlen(path); i++) {
+        if (pa_startswith(path + i, "/event"))
+            return path + i + 6;
+    }
+
+    return NULL;
+}
+
+static pa_bool_t input_node_belongs_to_device(
+        const char *device,
+        const char *node) {
+
+    char *cd;
+    pa_bool_t b;
+
+    cd = pa_sprintf_malloc("/sys%s", device);
+    b = pa_startswith(node, cd);
+    pa_xfree(cd);
+    return b;
+}
+
+
+static pa_strlist* alsa_jack_inputdev_udev_detect(struct udev* udev, const char* match_path) {
+    struct udev_enumerate *enumerate;
+    struct udev_list_entry *item, *first;
+    const char *jack_path;
+    const char *jack_input;
+    pa_strlist *result = NULL;
+
+    if (!(enumerate = udev_enumerate_new(udev)))
+        pa_log("Failed to initialize udev enumerator");
+    else {
+        if (udev_enumerate_add_match_subsystem(enumerate, "input"))
+            pa_log_debug("Failed to match to subsystem input");
+
+        if (udev_enumerate_scan_devices(enumerate))
+            pa_log_debug("Failed to scan for devices");
+        pa_log_debug("Matching against %s", match_path);
+        first = udev_enumerate_get_list_entry(enumerate);
+        udev_list_entry_foreach(item, first) {
+            jack_path = udev_list_entry_get_name(item);
+            pa_log_debug("testing %s", jack_path);
+            if (input_node_belongs_to_device(match_path, jack_path)) {
+                jack_input = jack_get_input_id(jack_path);
+                if (jack_input) {
+                    pa_log_debug("found jack input device %s\n", jack_input);
+                    result = pa_strlist_prepend(result, jack_input);
+                }
+            }
+        }
+        udev_enumerate_unref(enumerate);
+    }
+    return result;
+}
+
+/* (mostly) from slimlogic/wolfson end */
+
+static void jack_report(struct jack_inputdev *dev, uint64_t bitmask, uint64_t bitvalue) {
+    struct port_controlinfo *pc;
+    pa_hashmap *hm = NULL;
+    void* state;
+/*    pa_log_debug("bitmask = 0x%llx, bitvalue = 0x%llx", bitmask, bitvalue); */
+    PA_HASHMAP_FOREACH(pc, dev->port_controls, state) {
+        if (pc->switches_enable & bitmask) {
+            if (!hm)
+                hm = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+            pa_hashmap_put(hm, pc->port, pc->port);
+            pa_device_port_set_available(pc->port, bitmask & bitvalue ? PA_PORT_AVAILABLE_YES : PA_PORT_AVAILABLE_NO);
+        }
+    }
+
+    /* FIXME: should this really be done here? */
+    if (!hm)
+        return;
+    pa_hook_fire(&dev->core->hooks[PA_CORE_HOOK_PORTS_AVAILABLE_CHANGED], hm);
+    pa_hashmap_free(hm, NULL, NULL);
+}
+
+static void jack_get_initial_state(struct jack_inputdev *u)
+{
+    uint64_t switches;
+    int err;
+
+    pa_assert(SW_MAX < 63);
+    err = ioctl(u->fd, EVIOCGSW(sizeof(switches)), &switches);
+    if (err < 0) {
+        pa_log("Failed to read initial %s jack status %s", u->devname, strerror(errno));
+        return;
+    }
+
+    /* We got all bits, set them correctly */
+    jack_report(u, (1 << (SW_MAX+1)) - 1, switches);
+}
+
+
+static char* get_match_path_from_card_idx(struct udev* udev, int card_idx) {
+    char* t;
+    struct udev_device* card;
+
+    t = pa_sprintf_malloc("%s/class/sound/card%i", udev_get_sys_path(udev), card_idx);
+    card = udev_device_new_from_syspath(udev, t);
+    pa_xfree(t);
+    if (!card) {
+        pa_log_error("Udev error getting udev device :-(");
+        return NULL;
+    }
+
+    return pa_xstrdup(udev_device_get_devpath(card));
+}
+
+static void jack_inputdev_free(struct jack_inputdev* dev, void* dummy) {
+
+    if (!dev)
+        return;
+
+    if (dev->port_controls) {
+        struct port_controlinfo* pc;
+        while ((pc = pa_hashmap_steal_first(dev->port_controls))) {
+            if (pc->port)
+                pa_device_port_unref(pc->port);
+            pa_xfree(pc);
+        }
+        pa_hashmap_free(dev->port_controls, NULL, NULL);
+    }
+
+    if (dev->io_event && dev->core) {
+        dev->core->mainloop->io_free(dev->io_event);
+    }
+
+    if (dev->fd)
+        close(dev->fd);
+
+    pa_xfree(dev);
+}
+
+const char* swstrings[SW_MAX+1] = {
+    [SW_HEADPHONE_INSERT] = "Headphone",
+    [SW_MICROPHONE_INSERT] = "Microphone",
+    [SW_LINEOUT_INSERT] = "LineOut",
+    [SW_VIDEOOUT_INSERT] = "VideoOut",
+};
+
+static int match_input_dev_to_ports(pa_hashmap* ports, struct jack_inputdev* dev) {
+    int result = 0;
+    void *state = NULL;
+    pa_device_port *port;
+
+    if (!ports)
+        return 0;
+
+    PA_HASHMAP_FOREACH(port, ports, state) {
+        pa_alsa_port_data *alsa_port;
+        pa_alsa_path *path;
+        uint64_t switches = 0;
+        int i;
+        struct port_controlinfo *pc;
+
+        /* pa_log_debug("testing against port %p %s", port, pa_strnull(port->name)); */
+        alsa_port = PA_DEVICE_PORT_DATA(port);
+        path = alsa_port->path;
+        pa_log_debug("testing against path %s", pa_strnull(path->name));
+        /* pa_log_debug("testing against name = %s code = %s", pa_strnull(path->jack_inputdev_name), pa_strnull(path->jack_inputdev_code)); */
+        if (!path->jack_inputdev_name && !path->jack_inputdev_code)
+            continue;
+
+        if (path->jack_inputdev_name) {
+            if (!strstr(dev->devname, path->jack_inputdev_name)) {
+                pa_log_debug("names do not match");
+                continue;
+            }
+        }
+
+        for (i = 0; i < SW_MAX; i++) {
+            if ((dev->switches_supported & (1 << i)) == 0)
+                continue;
+            if (!swstrings[i])
+                continue;
+            if ((!path->jack_inputdev_code) || strstr(path->jack_inputdev_code, swstrings[i])) {
+                pa_log_debug("listens to %s events", swstrings[i]);
+                switches |= (1 << i);
+            }
+        }
+        if (switches == 0)
+            continue;
+
+        /* Found a match, let's add it! */
+        pc = pa_xnew0(struct port_controlinfo, 1);
+        pa_device_port_ref(port);
+        pc->port = port;
+        pc->switches_enable = switches;
+        pa_hashmap_put(dev->port_controls, pc, pc);
+        pa_log_debug("Added device %s to control port %s", dev->devname, pa_strnull(port->name));
+        result++;
+    }
+    return result;
+}
+
+static void match_input_dev_to_profiles(pa_idxset* devs, const char* jack_id, pa_hashmap* card_profiles) {
+    const char *devpath = pa_sprintf_malloc("/dev/input/event%s", jack_id);
+    int fd;
+    char devname[256] = "";
+    int64_t switches = 0;
+
+    pa_assert(SW_MAX <= 63); /* Or switches variable will overflow */
+    pa_assert(card_profiles);
+    pa_assert(devs);
+
+    fd = open(devpath, O_RDONLY);
+    if (fd < 0) {
+        pa_log_info("Could not open %s, error = %s", devpath, strerror(errno));
+        return;
+    }
+
+    if (ioctl(fd, EVIOCGNAME(sizeof(devname)), devname) < 0) {
+        pa_log_warn("Ioctl EVIOCGNAME error %s", strerror(errno));
+        goto finish;
+    }
+    pa_log_debug("Device %s has name \"%s\".", devpath, devname);
+
+    if (ioctl(fd, EVIOCGBIT(EV_SW, SW_MAX), &switches) < 0) {
+        pa_log_warn("Ioctl EVIOCGBIT error %s", strerror(errno));
+        goto finish;
+    }
+
+    if (switches == 0) {
+        pa_log_debug("Device %s does not have any switches.", devname);
+        goto finish;
+    } else {
+        /* Start iterating through profiles -> ports -> alsa_path */
+        void *state;
+        pa_card_profile *profile;
+        int i = 0;
+        struct jack_inputdev *dev = pa_xnew0(struct jack_inputdev, 1);
+
+        dev->fd = fd;
+        dev->switches_supported = switches;
+        pa_log_debug("Device %s has switches 0x%x.", devname, (int) switches);
+        dev->devname = pa_xstrdup(devname);
+        dev->port_controls = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+        PA_HASHMAP_FOREACH(profile, card_profiles, state) {
+            i += match_input_dev_to_ports(profile->sink_ports, dev);
+            i += match_input_dev_to_ports(profile->source_ports, dev);
+        }
+        if (i == 0) {
+            pa_log_debug("No matching paths/ports found for device %s", devname);
+            jack_inputdev_free(dev, NULL);
+        }
+        else
+            pa_idxset_put(devs, dev, NULL);
+        return;
+    }
+
+finish:
+        close(fd);
+}
+
+static void jack_inputdev_cb(pa_mainloop_api*ea, pa_io_event* e, int fd, pa_io_event_flags_t events, void *userdata) {
+    struct jack_inputdev* dev = userdata;
+    struct input_event event;
+
+    pa_assert(dev);
+
+    if (pa_read(dev->fd, &event, sizeof(event), NULL) != sizeof(event)) {
+        pa_log_warn("Failed to read event from dev %s", dev->devname);
+        return;
+    }
+
+    pa_log_debug("jack_report: name %s event type %x code %x value %x", dev->devname, event.type, event.code, event.value);
+    if (event.type == EV_SW)
+        jack_report(dev, 1 << event.code, event.value ? ~0 : 0);
+}
+
+static void jack_inputdev_start_listening(struct jack_inputdev* dev, pa_core* core) {
+    pa_assert(dev);
+
+    dev->core = core;
+    dev->io_event = core->mainloop->io_new(core->mainloop, dev->fd, PA_IO_EVENT_INPUT, jack_inputdev_cb, dev);
+    if (!dev->io_event) {
+        pa_log_warn("Failed to create io event for dev %s :-(", dev->devname);
+        return;
+    }
+    core->mainloop->io_enable(dev->io_event, PA_IO_EVENT_INPUT);
+    jack_get_initial_state(dev);
+}
+
+pa_idxset* pa_alsa_jack_inputdevs_init(pa_core* core, pa_hashmap* card_profiles, int alsa_card_index) {
+    pa_idxset *result = NULL;
+    struct udev* udev = NULL;
+    char* match_path = NULL;
+    pa_strlist* jack_names = NULL;
+    struct jack_inputdev* dev;
+    uint32_t state;
+
+    pa_assert(card_profiles);
+
+    if (!(udev = udev_new())) {
+        pa_log("Failed to open udev context.");
+        goto finish;
+    }
+
+    /* Step 1: Get a sysfs path to match input devices to */
+    if (!(match_path = get_match_path_from_card_idx(udev, alsa_card_index)))
+        goto finish;
+
+    /* Step 2: Enumerate all input devices */
+    jack_names = alsa_jack_inputdev_udev_detect(udev, match_path);
+    if (!jack_names) {
+        pa_log_debug("No jack input devices found belonging to this card.");
+        goto finish;
+    }
+
+    /* Step 3: Match input devices to profiles and ports */
+    result = pa_idxset_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+    while (jack_names) {
+        char* jack_id;
+        jack_names = pa_strlist_pop(jack_names, &jack_id);
+        match_input_dev_to_profiles(result, jack_id, card_profiles);
+        pa_xfree(jack_id);
+    }
+
+    /* Step 4: Start the input devices */
+    PA_IDXSET_FOREACH(dev, result, state)
+        jack_inputdev_start_listening(dev, core);
+
+finish:
+    if (match_path)
+        pa_xfree(match_path);
+    if (udev)
+        udev_unref(udev);
+    return result;
+}
+
+void pa_alsa_jack_inputdevs_free(pa_idxset* p)
+{
+
+    if (!p)
+        return;
+    pa_idxset_free(p, (pa_free2_cb_t) jack_inputdev_free, NULL);
+}
diff --git a/src/modules/alsa/alsa-jack-inputdev.h b/src/modules/alsa/alsa-jack-inputdev.h
new file mode 100644
index 0000000..00a6b61
--- /dev/null
+++ b/src/modules/alsa/alsa-jack-inputdev.h
@@ -0,0 +1,32 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2011 Canonical Ltd
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2.1 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+#ifndef fooalsajackinputdevhfoo
+#define fooalsajackinputdevhfoo
+
+#include <pulsecore/idxset.h>
+#include <pulsecore/hashmap.h>
+#include <pulsecore/core.h>
+
+pa_idxset* pa_alsa_jack_inputdevs_init(pa_core* core, pa_hashmap* card_profiles, int alsa_card_index);
+
+void pa_alsa_jack_inputdevs_free(pa_idxset* p);
+
+#endif
diff --git a/src/modules/alsa/alsa-mixer.c b/src/modules/alsa/alsa-mixer.c
index f5fcae0..80a7d63 100644
--- a/src/modules/alsa/alsa-mixer.c
+++ b/src/modules/alsa/alsa-mixer.c
@@ -355,6 +355,28 @@ static int prepare_mixer(snd_mixer_t *mixer, const char *dev) {
     return 0;
 }
 
+snd_mixer_t *pa_alsa_open_mixer_by_index(int card_idx) {
+    char *md;
+    int err;
+    snd_mixer_t *m;
+
+    if ((err = snd_mixer_open(&m, 0)) < 0) {
+        pa_log("Error opening mixer: %s", pa_alsa_strerror(err));
+        return NULL;
+    }
+
+    md = pa_sprintf_malloc("hw:%i", card_idx);
+
+    if (prepare_mixer(m, md) >= 0) {
+        pa_xfree(md);
+        return m;
+    }
+
+    pa_xfree(md);
+    snd_mixer_close(m);
+    return NULL;
+}
+
 snd_mixer_t *pa_alsa_open_mixer_for_pcm(snd_pcm_t *pcm, char **ctl_device) {
     int err;
     snd_mixer_t *m;
@@ -2325,6 +2347,10 @@ pa_alsa_path* pa_alsa_path_new(const char *fname, pa_alsa_direction_t direction)
         { "description",         pa_config_parse_string,            NULL, "General" },
         { "name",                pa_config_parse_string,            NULL, "General" },
 
+        /* [Jack_InputDevice] */
+        { "name",                pa_config_parse_string,            NULL, "Jack_InputDevice" },
+        { "code",                pa_config_parse_string,            NULL, "Jack_InputDevice" },
+
         /* [Option ...] */
         { "priority",            option_parse_priority,             NULL, NULL },
         { "name",                option_parse_name,                 NULL, NULL },
@@ -2356,6 +2382,9 @@ pa_alsa_path* pa_alsa_path_new(const char *fname, pa_alsa_direction_t direction)
     items[1].data = &p->description;
     items[2].data = &p->name;
 
+    items[3].data = &p->jack_inputdev_name;
+    items[4].data = &p->jack_inputdev_code;
+
     fn = pa_maybe_prefix_path(fname,
                               pa_run_from_build_tree() ? PA_BUILDDIR "/modules/alsa/mixer/paths/" :
                               PA_ALSA_PATHS_DIR);
@@ -3035,6 +3064,11 @@ static void path_set_condense(pa_alsa_path_set *ps, snd_mixer_t *m) {
             if (p == p2)
                 continue;
 
+            /* FIXME: subset also if p is empty and p2 is not...? */
+            if (p->jack_inputdev_name != p2->jack_inputdev_name ||
+                p->jack_inputdev_code != p2->jack_inputdev_code)
+                continue;
+
             /* Compare the elements of each set... */
             pa_assert_se(ea = p->elements);
             pa_assert_se(eb = p2->elements);
diff --git a/src/modules/alsa/alsa-mixer.h b/src/modules/alsa/alsa-mixer.h
index d92d3e9..5098e86 100644
--- a/src/modules/alsa/alsa-mixer.h
+++ b/src/modules/alsa/alsa-mixer.h
@@ -167,6 +167,9 @@ struct pa_alsa_path {
     char *description;
     unsigned priority;
 
+    char *jack_inputdev_name;
+    char *jack_inputdev_code;
+
     pa_bool_t probed:1;
     pa_bool_t supported:1;
     pa_bool_t has_mute:1;
@@ -304,6 +307,7 @@ void pa_alsa_profile_set_free(pa_alsa_profile_set *s);
 void pa_alsa_profile_set_dump(pa_alsa_profile_set *s);
 
 snd_mixer_t *pa_alsa_open_mixer_for_pcm(snd_pcm_t *pcm, char **ctl_device);
+snd_mixer_t *pa_alsa_open_mixer_by_index(int card_idx);
 
 pa_alsa_fdlist *pa_alsa_fdlist_new(void);
 void pa_alsa_fdlist_free(pa_alsa_fdlist *fdl);
diff --git a/src/modules/alsa/mixer/paths/analog-input-aux.conf b/src/modules/alsa/mixer/paths/analog-input-aux.conf
index 3a7cb7b..e6aa064 100644
--- a/src/modules/alsa/mixer/paths/analog-input-aux.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-aux.conf
@@ -19,7 +19,7 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 90
+priority = 80
 name = analog-input
 
 [Element Capture]
diff --git a/src/modules/alsa/mixer/paths/analog-input-dock-mic.conf b/src/modules/alsa/mixer/paths/analog-input-dock-mic.conf
index 74826a9..9d9fc0a 100644
--- a/src/modules/alsa/mixer/paths/analog-input-dock-mic.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-dock-mic.conf
@@ -19,9 +19,13 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 80
+priority = 78
 name = analog-input-microphone-dock
 
+[Jack_InputDevice]
+code = Microphone
+name = Dock
+
 [Element Dock Mic Boost]
 required-any = any
 switch = select
diff --git a/src/modules/alsa/mixer/paths/analog-input-front-mic.conf b/src/modules/alsa/mixer/paths/analog-input-front-mic.conf
index 6c58ece..12da7d8 100644
--- a/src/modules/alsa/mixer/paths/analog-input-front-mic.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-front-mic.conf
@@ -19,9 +19,13 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 90
+priority = 85
 name = analog-input-microphone-front
 
+[Jack_InputDevice]
+code = Microphone
+name = Front
+
 [Element Front Mic Boost]
 required-any = any
 switch = select
diff --git a/src/modules/alsa/mixer/paths/analog-input-linein.conf b/src/modules/alsa/mixer/paths/analog-input-linein.conf
index 461cebd..d5ffd65 100644
--- a/src/modules/alsa/mixer/paths/analog-input-linein.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-linein.conf
@@ -19,7 +19,7 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 90
+priority = 80
 
 [Element Capture]
 switch = mute
diff --git a/src/modules/alsa/mixer/paths/analog-input-mic-line.conf b/src/modules/alsa/mixer/paths/analog-input-mic-line.conf
index fa680aa..fb80838 100644
--- a/src/modules/alsa/mixer/paths/analog-input-mic-line.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-mic-line.conf
@@ -19,7 +19,7 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 90
+priority = 85
 name = analog-input
 
 [Element Capture]
diff --git a/src/modules/alsa/mixer/paths/analog-input-mic.conf b/src/modules/alsa/mixer/paths/analog-input-mic.conf
index d88028b..8ca00fd 100644
--- a/src/modules/alsa/mixer/paths/analog-input-mic.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-mic.conf
@@ -19,9 +19,12 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 89
+priority = 87
 name = analog-input-microphone
 
+[Jack_InputDevice]
+code = Microphone
+
 [Element Mic Boost]
 required-any = any
 switch = select
diff --git a/src/modules/alsa/mixer/paths/analog-input-rear-mic.conf b/src/modules/alsa/mixer/paths/analog-input-rear-mic.conf
index 75ed61b..deeb812 100644
--- a/src/modules/alsa/mixer/paths/analog-input-rear-mic.conf
+++ b/src/modules/alsa/mixer/paths/analog-input-rear-mic.conf
@@ -19,9 +19,13 @@
 ; See analog-output.conf.common for an explanation on the directives
 
 [General]
-priority = 89
+priority = 82
 name = analog-input-microphone-rear
 
+[Jack_InputDevice]
+code = Microphone
+name = Rear
+
 [Element Rear Mic Boost]
 required-any = any
 switch = select
diff --git a/src/modules/alsa/mixer/paths/analog-output-headphones.conf b/src/modules/alsa/mixer/paths/analog-output-headphones.conf
index 1d7bb0b..ccc2d88 100644
--- a/src/modules/alsa/mixer/paths/analog-output-headphones.conf
+++ b/src/modules/alsa/mixer/paths/analog-output-headphones.conf
@@ -22,6 +22,9 @@
 priority = 90
 name = analog-output-headphones
 
+[Jack_InputDevice]
+code = Headphone
+
 [Element Hardware Master]
 switch = mute
 volume = merge
diff --git a/src/modules/alsa/module-alsa-card.c b/src/modules/alsa/module-alsa-card.c
index e60aa5e..a837ca8 100644
--- a/src/modules/alsa/module-alsa-card.c
+++ b/src/modules/alsa/module-alsa-card.c
@@ -39,6 +39,7 @@
 #include "alsa-util.h"
 #include "alsa-sink.h"
 #include "alsa-source.h"
+#include "alsa-jack-inputdev.h"
 #include "module-alsa-card-symdef.h"
 
 PA_MODULE_AUTHOR("Lennart Poettering");
@@ -106,12 +107,51 @@ struct userdata {
     pa_modargs *modargs;
 
     pa_alsa_profile_set *profile_set;
+
+    pa_idxset *jack_inputdevs;
 };
 
 struct profile_data {
     pa_alsa_profile *profile;
 };
 
+static void add_ports_from_mapping(struct userdata *u, pa_hashmap *dest, pa_alsa_mapping *m, int direction) {
+    pa_device_port *port;
+    pa_hashmap *ports = NULL;
+    pa_alsa_path_set *mixer_path_set = NULL;
+    snd_mixer_t *mixer_handle = NULL;
+    void *state;
+
+    /* FIXME: check ignoredb, control modargs, check mixer by name */
+
+    if (!(mixer_handle = pa_alsa_open_mixer_by_index(snd_card_get_index(u->device_id))))
+        goto cleanup;
+    if (!(mixer_path_set = pa_alsa_path_set_new(m, direction)))
+        goto cleanup;
+    pa_alsa_path_set_probe(mixer_path_set, mixer_handle, 0);
+    pa_log_debug("Probed mixer paths in add_ports_from_mapping:");
+    pa_alsa_path_set_dump(mixer_path_set);
+
+    pa_alsa_add_ports(&ports, mixer_path_set);
+    if (ports)
+        PA_HASHMAP_FOREACH(port, ports, state)
+            if (pa_hashmap_get(dest, port->name) == NULL) {
+                pa_hashmap_put(dest, port->name, pa_device_port_ref(port));
+                pa_log_debug("Ref port %s, refcnt (after) = %d", port->name, pa_device_port_refcnt(port));
+
+            }
+
+cleanup:
+    if (ports)
+        pa_device_port_hashmap_free(ports);
+    /* FIXME: Some paths are now referenced in the port data. Free only those who are not...? */
+    /* if (mixer_path_set)
+        pa_alsa_path_set_free(mixer_path_set); */
+    if (mixer_handle)
+        snd_mixer_close(mixer_handle);
+
+}
+
 static void add_profiles(struct userdata *u, pa_hashmap *h) {
     pa_alsa_profile *ap;
     void *state;
@@ -130,18 +170,23 @@ static void add_profiles(struct userdata *u, pa_hashmap *h) {
 
         if (ap->output_mappings) {
             cp->n_sinks = pa_idxset_size(ap->output_mappings);
+            cp->sink_ports = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
 
-            PA_IDXSET_FOREACH(m, ap->output_mappings, idx)
+            PA_IDXSET_FOREACH(m, ap->output_mappings, idx) {
+                add_ports_from_mapping(u, cp->sink_ports, m, PA_ALSA_DIRECTION_OUTPUT);
                 if (m->channel_map.channels > cp->max_sink_channels)
                     cp->max_sink_channels = m->channel_map.channels;
+            }
         }
 
         if (ap->input_mappings) {
             cp->n_sources = pa_idxset_size(ap->input_mappings);
-
-            PA_IDXSET_FOREACH(m, ap->input_mappings, idx)
+            cp->source_ports = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
+            PA_IDXSET_FOREACH(m, ap->input_mappings, idx) {
+                add_ports_from_mapping(u, cp->source_ports, m, PA_ALSA_DIRECTION_INPUT);
                 if (m->channel_map.channels > cp->max_source_channels)
                     cp->max_source_channels = m->channel_map.channels;
+            }
         }
 
         d = PA_CARD_PROFILE_DATA(cp);
@@ -387,6 +432,8 @@ int pa__init(pa_module *m) {
         goto fail;
     }
 
+    u->jack_inputdevs = pa_alsa_jack_inputdevs_init(u->core, data.profiles, alsa_card_index);
+
     u->card = pa_card_new(m->core, &data);
     pa_card_new_data_done(&data);
 
@@ -448,6 +495,9 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         goto finish;
 
+    if (u->jack_inputdevs)
+        pa_alsa_jack_inputdevs_free(u->jack_inputdevs);
+
     if (u->card && u->card->sinks) {
         pa_sink *s;
 
diff --git a/src/modules/module-switch-on-connect.c b/src/modules/module-switch-on-connect.c
index b121fd9..3ee38b8 100644
--- a/src/modules/module-switch-on-connect.c
+++ b/src/modules/module-switch-on-connect.c
@@ -32,6 +32,9 @@
 #include <pulsecore/modargs.h>
 #include <pulsecore/log.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/device-port.h>
+#include <pulsecore/hashmap.h>
+#include <pulsecore/card.h>
 #include <pulsecore/core-util.h>
 
 #include "module-switch-on-connect-symdef.h"
@@ -48,9 +51,138 @@ static const char* const valid_modargs[] = {
 struct userdata {
     pa_hook_slot
         *sink_put_slot,
-        *source_put_slot;
+        *source_put_slot,
+        *ports_put_slot;
 };
 
+static void find_port(pa_core *core, pa_device_port *port, pa_card**card,
+    pa_card_profile**profile, pa_sink**sink, pa_source**source) {
+
+    void *state2, *state4;
+    uint32_t state, state3;
+    pa_card*c;
+    pa_card_profile*pr;
+    pa_sink*si;
+    pa_source*so;
+
+    *sink = NULL;
+    *source = NULL;
+
+    PA_IDXSET_FOREACH(c, core->cards, state) {
+        if (!c->profiles) {
+            pa_log_debug("card %s has no profiles?", pa_strnull(c->name));
+            continue;
+        }
+        PA_HASHMAP_FOREACH(pr, c->profiles, state2) {
+            pa_bool_t found = FALSE;
+            pa_device_port* dp;
+            pa_log_debug("searching card %s profile %s", pa_strnull(c->name), pa_strnull(pr->name));
+            /* pa_log_debug("sinkports %s", pr->sink_ports ? "yes" : "no"); */
+            pa_log_debug("looking for port %p, %s", port, port->name);
+
+            if (pr->sink_ports)
+                PA_HASHMAP_FOREACH(dp, pr->sink_ports, state4) {
+                      /* pa_log_debug("checking port %p, %s", dp, dp->name); */
+                      if (dp == port) found = TRUE;
+                }
+
+            if (found) {
+                PA_IDXSET_FOREACH(si, c->sinks, state3) {
+                    if (!si->ports)
+                        continue;
+                    PA_HASHMAP_FOREACH(dp, si->ports, state4)
+                        /* pa_log_debug("checking sink %p, port %p %s", si, dp, dp->name); */
+                        if (strcmp(dp->name, port->name) == 0) {
+                            *sink = si;
+                            pa_log_debug("found sink %p, %s", si, si->name);
+                        }
+                }
+                *card = c;
+                *profile = pr;
+                return;
+            }
+
+            if (pr->source_ports)
+                PA_HASHMAP_FOREACH(dp, pr->source_ports, state4) {
+                      if (dp == port) found = TRUE;
+                }
+
+            if (found) {
+                pa_assert(c->sources);
+                PA_IDXSET_FOREACH(so, c->sources, state3) {
+                    if (!so->ports)
+                        continue;
+                    PA_HASHMAP_FOREACH(dp, so->ports, state4)
+                        if (strcmp(dp->name, port->name) == 0) {
+                            *source = so;
+                            pa_log_debug("found source %p, %s", so, so->name);
+                        }
+                }
+                *card = c;
+                *profile = pr;
+                return;
+            }
+        }
+    }
+    pa_log_warn("ehhh...port does not belong anywhere");
+    *card = NULL;
+    *profile = NULL;
+}
+
+static pa_device_port* find_best_port(pa_hashmap *ports) {
+    void *state;
+    pa_device_port* port, *result = NULL;
+    unsigned prio = 0;
+
+    PA_HASHMAP_FOREACH(port, ports, state) {
+        if (result == NULL || (port->available != PA_PORT_AVAILABLE_NO && port->priority > prio)) {
+            result = port;
+            prio = port->priority;
+        }
+    }
+    pa_assert(result != NULL);
+    return result;
+}
+
+static pa_hook_result_t ports_available_put_hook_callback(pa_core *c, pa_hashmap *ports, void* userdata) {
+    void* state;
+    pa_device_port* port;
+    pa_card* card;
+    pa_card_profile* profile;
+    pa_sink* sink;
+    pa_source* source;
+
+    pa_log_debug("ports_available_put_hook_callback");
+
+    PA_HASHMAP_FOREACH(port, ports, state) {
+        pa_log_debug("finding port %s", port->name);
+        find_port(c, port, &card, &profile, &sink, &source);
+        if (!card)
+            continue;
+        if (card->active_profile != profile) {
+            pa_log_debug("not active profile - skipping for now");
+            continue;
+        }
+        if (port->available == PA_PORT_AVAILABLE_YES) {
+            if (sink && sink->active_port != port)
+                pa_sink_set_port(sink, port->name, FALSE);
+            if (source && source->active_port != port)
+                pa_source_set_port(source, port->name, FALSE);
+        }
+
+        if (port->available == PA_PORT_AVAILABLE_NO) {
+            if (sink && sink->active_port && !strcmp(sink->active_port->name, port->name))
+                pa_sink_set_port(sink, find_best_port(sink->ports)->name, FALSE);
+            if (source && source->active_port && !strcmp(source->active_port->name, port->name))
+                pa_source_set_port(source, find_best_port(source->ports)->name, FALSE);
+        }
+
+    }
+
+    return PA_HOOK_OK;
+}
+
+
 static pa_hook_result_t sink_put_hook_callback(pa_core *c, pa_sink *sink, void* userdata) {
     pa_sink_input *i;
     uint32_t idx;
@@ -165,6 +297,8 @@ int pa__init(pa_module*m) {
     /* A little bit later than module-rescue-streams... */
     u->sink_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PUT], PA_HOOK_LATE+30, (pa_hook_cb_t) sink_put_hook_callback, u);
     u->source_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SOURCE_PUT], PA_HOOK_LATE+20, (pa_hook_cb_t) source_put_hook_callback, u);
+    u->ports_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_PORTS_AVAILABLE_CHANGED], PA_HOOK_LATE+20, (pa_hook_cb_t) ports_available_put_hook_callback, u);
+
 
     pa_modargs_free(ma);
     return 0;
@@ -178,6 +312,8 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    if (u->ports_put_slot)
+        pa_hook_slot_free(u->ports_put_slot);
     if (u->sink_put_slot)
         pa_hook_slot_free(u->sink_put_slot);
     if (u->source_put_slot)
diff --git a/src/pulsecore/card.c b/src/pulsecore/card.c
index feaa444..c760f70 100644
--- a/src/pulsecore/card.c
+++ b/src/pulsecore/card.c
@@ -49,6 +49,8 @@ pa_card_profile *pa_card_profile_new(const char *name, const char *description,
     c->priority = 0;
     c->n_sinks = c->n_sources = 0;
     c->max_sink_channels = c->max_source_channels = 0;
+    c->sink_ports = NULL;
+    c->source_ports = NULL;
 
     return c;
 }
@@ -56,6 +58,8 @@ pa_card_profile *pa_card_profile_new(const char *name, const char *description,
 void pa_card_profile_free(pa_card_profile *c) {
     pa_assert(c);
 
+    pa_device_port_hashmap_free(c->sink_ports);
+    pa_device_port_hashmap_free(c->source_ports);
     pa_xfree(c->name);
     pa_xfree(c->description);
     pa_xfree(c);
diff --git a/src/pulsecore/card.h b/src/pulsecore/card.h
index 2d691b6..a50a6c1 100644
--- a/src/pulsecore/card.h
+++ b/src/pulsecore/card.h
@@ -28,6 +28,7 @@ typedef struct pa_card pa_card;
 #include <pulsecore/core.h>
 #include <pulsecore/module.h>
 #include <pulsecore/idxset.h>
+#include <pulsecore/device-port.h>
 
 typedef struct pa_card_profile {
     char *name;
@@ -42,6 +43,9 @@ typedef struct pa_card_profile {
     unsigned max_sink_channels;
     unsigned max_source_channels;
 
+    pa_hashmap *sink_ports;
+    pa_hashmap *source_ports;
+
     /* .. followed by some implementation specific data */
 } pa_card_profile;
 
diff --git a/src/pulsecore/core.h b/src/pulsecore/core.h
index 61c8690..a75a47b 100644
--- a/src/pulsecore/core.h
+++ b/src/pulsecore/core.h
@@ -113,6 +113,7 @@ typedef enum pa_core_hook {
     PA_CORE_HOOK_CARD_PUT,
     PA_CORE_HOOK_CARD_UNLINK,
     PA_CORE_HOOK_CARD_PROFILE_CHANGED,
+    PA_CORE_HOOK_PORTS_AVAILABLE_CHANGED,
     PA_CORE_HOOK_MAX
 } pa_core_hook_t;
 
diff --git a/src/pulsecore/device-port.c b/src/pulsecore/device-port.c
index 9e6ad43..b3f6f84 100644
--- a/src/pulsecore/device-port.c
+++ b/src/pulsecore/device-port.c
@@ -62,3 +62,12 @@ void pa_device_port_hashmap_free(pa_hashmap *h) {
         pa_hashmap_free(h, NULL, NULL);
     }
 }
+
+void pa_device_port_set_available(pa_device_port *p, pa_port_available_t status) {
+    if (p->available == status)
+        return;
+    pa_assert(status != PA_PORT_AVAILABLE_UNKNOWN);
+    p->available = status;
+    pa_log_debug("Setting port %s to status %s", p->name, status == PA_PORT_AVAILABLE_YES ? "yes" : "no");
+    /* FIXME: Now fire a hook or something? */
+}
diff --git a/src/pulsecore/device-port.h b/src/pulsecore/device-port.h
index 23f6444..4c15268 100644
--- a/src/pulsecore/device-port.h
+++ b/src/pulsecore/device-port.h
@@ -55,6 +55,8 @@ PA_DECLARE_PUBLIC_CLASS(pa_device_port);
 
 pa_device_port *pa_device_port_new(const char *name, const char *description, size_t extra);
 
+void pa_device_port_set_available(pa_device_port *p, pa_port_available_t status);
+
 void pa_device_port_hashmap_free(pa_hashmap *h);
 
 #endif
-- 
1.7.5.4

