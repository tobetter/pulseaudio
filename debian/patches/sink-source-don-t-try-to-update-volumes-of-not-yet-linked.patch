From: Tanu Kaskinen <tanuk@iki.fi>
Date: Sun, 10 Sep 2017 22:32:56 +0300
Subject: sink, source: don't try to update volumes of not-yet-linked devices

The order of the pa_sink_input_put() and pa_sink_put() calls in filter
modules was swapped in commit edc465da77 ("virtual sources and sinks:
Don't double attach a sink input or source output on filter load").
If flat volumes and volume sharing is enabled, the pa_sink_input_put()
call will update volumes of the whole tree of virtual sinks that are
connected to the root sink. The recursive updating procedure tried to
also update the volume of the new sink for which pa_sink_put() had not
yet been called, causing an assertion failure.

This patch tries to make sure that the volume of not-yet-linked sinks
is never changed. pa_sink_put() will set the sink volume correctly, so
it's fine to skip the not-yet-linked sinks during pa_sink_input_put().

BugLink: https://bugs.freedesktop.org/show_bug.cgi?id=102549
(cherry picked from commit 759705bc4f1bc819dbfbc1f68c1b0b4bd3a18734)
---
 src/pulsecore/sink.c   | 21 ++++++++++++++-------
 src/pulsecore/source.c | 21 ++++++++++++++-------
 2 files changed, 28 insertions(+), 14 deletions(-)

diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index a8b4cd3..2ea874a 100644
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -1710,7 +1710,8 @@ static void compute_reference_ratios(pa_sink *s) {
     PA_IDXSET_FOREACH(i, s->inputs, idx) {
         compute_reference_ratio(i);
 
-        if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER))
+        if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER)
+                && PA_SINK_IS_LINKED(i->origin_sink->state))
             compute_reference_ratios(i->origin_sink);
     }
 }
@@ -1737,7 +1738,8 @@ static void compute_real_ratios(pa_sink *s) {
             pa_cvolume_reset(&i->real_ratio, i->real_ratio.channels);
             i->soft_volume = i->volume_factor;
 
-            compute_real_ratios(i->origin_sink);
+            if (PA_SINK_IS_LINKED(i->origin_sink->state))
+                compute_real_ratios(i->origin_sink);
 
             continue;
         }
@@ -1836,7 +1838,8 @@ static void get_maximum_input_volume(pa_sink *s, pa_cvolume *max_volume, const p
         pa_cvolume remapped;
 
         if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER)) {
-            get_maximum_input_volume(i->origin_sink, max_volume, channel_map);
+            if (PA_SINK_IS_LINKED(i->origin_sink->state))
+                get_maximum_input_volume(i->origin_sink, max_volume, channel_map);
 
             /* Ignore this input. The origin sink uses volume sharing, so this
              * input's volume will be set to be equal to the root sink's real
@@ -1892,7 +1895,8 @@ static void update_real_volume(pa_sink *s, const pa_cvolume *new_volume, pa_chan
                 compute_reference_ratio(i);
             }
 
-            update_real_volume(i->origin_sink, new_volume, channel_map);
+            if (PA_SINK_IS_LINKED(i->origin_sink->state))
+                update_real_volume(i->origin_sink, new_volume, channel_map);
         }
     }
 }
@@ -1947,7 +1951,8 @@ static void propagate_reference_volume(pa_sink *s) {
         pa_cvolume new_volume;
 
         if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER)) {
-            propagate_reference_volume(i->origin_sink);
+            if (PA_SINK_IS_LINKED(i->origin_sink->state))
+                propagate_reference_volume(i->origin_sink);
 
             /* Since the origin sink uses volume sharing, this input's volume
              * needs to be updated to match the root sink's real volume, but
@@ -2005,7 +2010,8 @@ static bool update_reference_volume(pa_sink *s, const pa_cvolume *v, const pa_ch
         return false;
 
     PA_IDXSET_FOREACH(i, s->inputs, idx) {
-        if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER))
+        if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER)
+                && PA_SINK_IS_LINKED(i->origin_sink->state))
             update_reference_volume(i->origin_sink, v, channel_map, false);
     }
 
@@ -2176,7 +2182,8 @@ static void propagate_real_volume(pa_sink *s, const pa_cvolume *old_real_volume)
             pa_sw_cvolume_multiply(&new_volume, &new_volume, &i->reference_ratio);
             pa_sink_input_set_volume_direct(i, &new_volume);
 
-            if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER))
+            if (i->origin_sink && (i->origin_sink->flags & PA_SINK_SHARE_VOLUME_WITH_MASTER)
+                    && PA_SINK_IS_LINKED(i->origin_sink->state))
                 propagate_real_volume(i->origin_sink, old_real_volume);
         }
     }
diff --git a/src/pulsecore/source.c b/src/pulsecore/source.c
index b2936c5..b9db4c6 100644
--- a/src/pulsecore/source.c
+++ b/src/pulsecore/source.c
@@ -1284,7 +1284,8 @@ static void compute_reference_ratios(pa_source *s) {
     PA_IDXSET_FOREACH(o, s->outputs, idx) {
         compute_reference_ratio(o);
 
-        if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER))
+        if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER)
+                && PA_SOURCE_IS_LINKED(o->destination_source->state))
             compute_reference_ratios(o->destination_source);
     }
 }
@@ -1311,7 +1312,8 @@ static void compute_real_ratios(pa_source *s) {
             pa_cvolume_reset(&o->real_ratio, o->real_ratio.channels);
             o->soft_volume = o->volume_factor;
 
-            compute_real_ratios(o->destination_source);
+            if (PA_SOURCE_IS_LINKED(o->destination_source->state))
+                compute_real_ratios(o->destination_source);
 
             continue;
         }
@@ -1410,7 +1412,8 @@ static void get_maximum_output_volume(pa_source *s, pa_cvolume *max_volume, cons
         pa_cvolume remapped;
 
         if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER)) {
-            get_maximum_output_volume(o->destination_source, max_volume, channel_map);
+            if (PA_SOURCE_IS_LINKED(o->destination_source->state))
+                get_maximum_output_volume(o->destination_source, max_volume, channel_map);
 
             /* Ignore this output. The origin source uses volume sharing, so this
              * output's volume will be set to be equal to the root source's real
@@ -1466,7 +1469,8 @@ static void update_real_volume(pa_source *s, const pa_cvolume *new_volume, pa_ch
                 compute_reference_ratio(o);
             }
 
-            update_real_volume(o->destination_source, new_volume, channel_map);
+            if (PA_SOURCE_IS_LINKED(o->destination_source->state))
+                update_real_volume(o->destination_source, new_volume, channel_map);
         }
     }
 }
@@ -1521,7 +1525,8 @@ static void propagate_reference_volume(pa_source *s) {
         pa_cvolume new_volume;
 
         if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER)) {
-            propagate_reference_volume(o->destination_source);
+            if (PA_SOURCE_IS_LINKED(o->destination_source->state))
+                propagate_reference_volume(o->destination_source);
 
             /* Since the origin source uses volume sharing, this output's volume
              * needs to be updated to match the root source's real volume, but
@@ -1579,7 +1584,8 @@ static bool update_reference_volume(pa_source *s, const pa_cvolume *v, const pa_
         return false;
 
     PA_IDXSET_FOREACH(o, s->outputs, idx) {
-        if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER))
+        if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER)
+                && PA_SOURCE_IS_LINKED(o->destination_source->state))
             update_reference_volume(o->destination_source, v, channel_map, false);
     }
 
@@ -1759,7 +1765,8 @@ static void propagate_real_volume(pa_source *s, const pa_cvolume *old_real_volum
             pa_sw_cvolume_multiply(&new_volume, &new_volume, &o->reference_ratio);
             pa_source_output_set_volume_direct(o, &new_volume);
 
-            if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER))
+            if (o->destination_source && (o->destination_source->flags & PA_SOURCE_SHARE_VOLUME_WITH_MASTER)
+                    && PA_SOURCE_IS_LINKED(o->destination_source->state))
                 propagate_real_volume(o->destination_source, old_real_volume);
         }
     }
